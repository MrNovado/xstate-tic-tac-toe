{"version":3,"sources":["reportWebVitals.ts","features/TicTacToe/TicTacToe.common.ts","features/TicTacToe/TicTacToe.actor.types.ts","features/TicTacToe/TicTacToe.actor.business.ts","features/TicTacToe/TicTacToe.actor.ts","features/TicTacToe/TicTacToe.machine.types.ts","features/TicTacToe/TicTacToe.machine.ts","components/MenuButton.tsx","pages/TicTacToePage/TicTacToePage.settingUp.tsx","common/noop.ts","components/TicTacToeField.tsx","pages/TicTacToePage/common.tsx","pages/TicTacToePage/TicTacToePage.playing.tsx","pages/TicTacToePage/TicTacToePage.endResults.tsx","pages/TicTacToePage/TicTacToePage.tsx","app-container/App.tsx","index.tsx"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","PLAYER_TYPE","PLAYER_NUM","PLAYER_SYMBOL","ROWS","COLUMNS","DIAGONALS","FIELD","corners","topLeft","topRight","botLeft","botRight","edges","top","left","right","bot","center","combinations","rows","columns","diagonals","FIELD_INITIAL","TTT_EVENT_TYPE","TTT_DELAY_OPTIONS","0","default","500","700","1000","TTT_ACTOR_EVENT_TYPE","TTT_ACTOR_STATE","TTT_ACTOR_GUARD","TTT_ACTOR_ACTION","getOpponent","symbol","MAKING_TURN_ACTION","target","S","cond","G","delay","ctx","transitionDelay","createTicTacToeActor","givenSymbol","createMachine","context","field","player","moveReady","initial","states","on","E","actions","A","after","entry","guards","type","assign","_","event","sendParent","Msg","index","turnTo","sender","tryWinning","tryForking","opponent","possibleOppositeCorners","is","filter","inv","oppositeCorner","sample","possibleFreeCorners","value","corner","freeCorner","possibleFreeSides","side","freeSide","combination","find","row","reduce","acc","find2InARowWith1Free","undefined","fork","oneTakenAnd2Blanks","line","length","intersection","intersectionEmpty","intersectionIndex","column","findAFork","TTT_STATE","TTT_ACTION","TTT_GUARD","initialContext","actorTransitionDelay","opponents","turnOrder","current","turnsMade","winCombo","surrendered","TicTacToeMachine","always","id","Boolean","currentPlayerInfo","kind","ref","stop","newPlayerSymbol","newPlayerInfo","spawn","name","first","send","newField","newSymbol","someCombo","a","b","c","hasFreeSpace","some","cellValue","MenuButton","styled","button","MenuContainer","div","TransitionDelaySelect","select","RENDER_DELAY_OPTIONS","Object","values","sort","map","TicTacToePageSettingUp","onClick","defaultValue","onChange","e","Number","noop","FieldGrid","FieldCell","isFirstTurn","isPlayersTurn","cellIndex","includes","TicTacToeField","React","memo","onCellClick","role","tabIndex","onKeyDown","GameContainer","TurnStateComment","h3","TicTacToePagePlaying","machineState","currentPlayer","currentPlayerSymbol","makeTurn","useMemo","disabled","EndResultComment","TicTacToePageEndResults","inspect","iframe","document","getElementById","TicTacToePageContainer","TicTacToePage","useMachine","devTools","useEffect","console","log","turn","events","matches","renderMachineState","App","ReactDOM","render","StrictMode"],"mappings":"gMAgBeA,G,MAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,Q,uGCTDQ,EACL,OADKA,EAEJ,QAUIC,EACF,UADEA,EAEF,UAKEC,EACR,IADQA,EAER,IAqBQC,EAA2B,CACtC,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAGIC,EAA8B,CACzC,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAGIC,EAAgC,CAC3C,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAGIC,EAAQ,CACnBC,QAAS,CACPC,QAAS,EACTC,SAAU,EACVC,QAAS,EACTC,SAAU,GAEZC,MAAO,CACLC,IAAK,EACLC,KAAM,EACNC,MAAO,EACPC,IAAK,GAEPC,OAAQ,EACRC,aAAa,GAAD,OAAMf,EAASC,EAAYC,GACvCc,KAAMhB,EACNiB,QAAShB,EACTiB,UAAWhB,GAGAiB,EAA8B,CAAC,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,MAE/EC,EACM,kBADNA,EAEE,cAFFA,EAGS,qBAHTA,EAIe,2BAJfA,EAKI,gBALJA,EAMA,YANAA,EAOD,WAPCA,EAQG,eAaHC,EAAoB,CAC/BC,EAAG,EACHC,QAAS,IACTC,IAAK,IACLC,IAAK,IACLC,IAAM,KAwBKC,EACE,cCtHFC,EACG,iBADHA,EAEC,eAFDA,EAGE,gBAHFA,EAIO,qBAJPA,EAKG,iBALHA,EAMQ,sBANRA,EAOS,uBAPTA,EAQiB,+BARjBA,EASS,uBATTA,EAUY,0BAVZA,EAWD,aAmBCC,EACM,kBAGNC,GACA,YADAA,GAED,WAFCA,GAGC,aAHDA,GAIK,iBAJLA,GAKC,aALDA,GAMM,kBANNA,GAOM,kBAPNA,GAQc,0BARdA,GASM,kBATNA,GAUI,gBAVJA,GAWH,S,SClDH,SAASC,GAAYC,GAC1B,OAAOA,IAAWjC,EAAkBA,EAAkBA,ECcxD,IAEMkC,GAAqB,CACzBC,OAAQC,EACRC,KAAMC,EACNC,MAAQ,SAACC,GAAD,OAASA,EAAIC,kBAWVC,GAAuB,SAClCC,GADkC,eAGlCC,YACE,CACEC,QAAS,CACPC,MAAO1B,EACP2B,OAAQhD,EACRkC,OAAQU,EACRK,UAAW,KACXP,gBAAiBnB,EAAkBE,SAErCyB,QAASb,EACTc,QAAM,mBACHd,EAAiB,CAChBe,GAAG,eACAC,EAAgB,CACfjB,OAAQC,EACRiB,QAAS,CAACC,QALZ,cAUHlB,EAAe,CAOdmB,MAAO,CACL,CACEpB,OAAQC,EACRiB,QAASC,GACTf,MAAO,SAACC,GAAD,OAASA,EAAIC,qBArBtB,cA0BHL,EAAgB,CACfoB,MAAOF,GACPC,MAAO,CACLrB,GACA,CACEC,OAAQC,EACRG,MAAO,SAACC,GAAD,OAASA,EAAIC,qBAhCtB,cAoCHL,EAAqB,CACpBoB,MAAOF,GACPC,MAAO,CACLrB,GACA,CACEC,OAAQC,EACRG,MAAO,SAACC,GAAD,OAASA,EAAIC,qBA1CtB,cA8CHL,EAAiB,CAChBoB,MAAOF,GACPC,MAAO,CACLrB,GACA,CACEC,OAAQC,EACRG,MAAO,SAACC,GAAD,OAASA,EAAIC,qBApDtB,cAwDHL,EAAsB,CACrBoB,MAAOF,GACPC,MAAO,CACLrB,GACA,CACEC,OAAQC,EACRG,MAAO,SAACC,GAAD,OAASA,EAAIC,qBA9DtB,cAkEHL,EAAuB,CACtBoB,MAAOF,GACPC,MAAO,CACLrB,GACA,CACEC,OAAQC,EACRG,MAAO,SAACC,GAAD,OAASA,EAAIC,qBAxEtB,cA4EHL,EAA+B,CAC9BoB,MAAOF,GACPC,MAAO,CACLrB,GACA,CACEC,OAAQC,EACRG,MAAO,SAACC,GAAD,OAASA,EAAIC,qBAlFtB,cAsFHL,EAAuB,CACtBoB,MAAOF,GACPC,MAAO,CACLrB,GACA,CACEC,OAAQC,EACRG,MAAO,SAACC,GAAD,OAASA,EAAIC,qBA5FtB,cAgGHL,EAA0B,CACzBoB,MAAOF,GACPC,MAAO,CACLrB,GACA,CACEC,OAAQC,EACRG,MAAO,SAACC,GAAD,OAASA,EAAIC,qBAtGtB,cA2GHL,EAAa,CACZmB,MAAO,CACL,CACEpB,OAAQC,EACRiB,QAASC,GACTf,MAAO,SAACC,GAAD,OAASA,EAAIC,qBAhHtB,IAsHR,CACEgB,OAAO,eACJnB,GAAoB,gBAAGU,EAAH,EAAGA,UAAH,MAA8D,YAAX,OAATA,QAAS,IAATA,OAAA,EAAAA,EAAWU,SAE5EL,SAAO,mBAKJC,GAAcK,YAAO,CACpBZ,OAAQ,SAACa,EAAGC,GAAJ,OAAcA,EAAMd,QAC5BD,MAAO,SAACc,EAAGC,GAAJ,OAAcA,EAAMf,OAC3BL,gBAAiB,SAACmB,EAAGC,GAAJ,OAAcA,EAAMpB,oBARlC,cAWJa,GAAaQ,aACZ,YAMM,IALJf,EAKG,EALHA,OACAC,EAIG,EAJHA,UAKA,MAAwB,YAAX,OAATA,QAAS,IAATA,OAAA,EAAAA,EAAWU,MACN,CAAEA,KAAMK,EAAmBC,MAAOhB,EAAUiB,OAAQC,OAAQnB,GAG9D,CAAEW,KAAMK,KAEjB,CAAExB,MAhLM,OAuJL,cA4BJe,GAAWQ,aACV,WACE,MAAO,CAAEJ,KAAMK,KAEjB,CAAExB,MAvLM,OAuJL,cAuCJe,GAAeK,YAAO,CACrBX,UAAW,YACT,OAAOmB,GADyB,EAApBrB,MAAoB,EAAbb,YAxClB,cA4CJqB,GAAmBK,YAAO,CACzBX,UAAW,YAET,OAAOmB,GAFyB,EAApBrB,MACWd,GADS,EAAbC,aA7ClB,cAkDJqB,GAAeK,YAAO,CACrBX,UAAW,YACT,OAAOoB,GADyB,EAApBtB,MAAoB,EAAbb,YAnDlB,cAuDJqB,GAAoBK,YAAO,CAC1BX,UAAW,YAET,OAAOoB,GAFyB,EAApBtB,MACWd,GADS,EAAbC,aAxDlB,cA6DJqB,GAAoBK,YAAO,CAC1BX,UAAW,YACT,OAA4B,OADJ,EAAZF,MACF1C,EAAMW,QACP,CAAE2C,KAAM,SAAUO,OAAQ7D,EAAMW,QAGlC,CAAE2C,KAAM,oBAnEd,cAsEJJ,GAA4BK,YAAO,CAClCX,UAAW,YAAwB,IAArBF,EAAoB,EAApBA,MACNuB,EAAWrC,GADe,EAAbC,QAuBbqC,EAnBU,CACd,CACEC,GAAIzB,EAAM1C,EAAMC,QAAQC,WAAa+D,GAA8C,OAAlCvB,EAAM1C,EAAMC,QAAQI,UACrEuD,MAAO5D,EAAMC,QAAQI,UAEvB,CACE8D,GAAIzB,EAAM1C,EAAMC,QAAQE,YAAc8D,GAA6C,OAAjCvB,EAAM1C,EAAMC,QAAQG,SACtEwD,MAAO5D,EAAMC,QAAQG,SAEvB,CACE+D,GAAIzB,EAAM1C,EAAMC,QAAQG,WAAa6D,GAA8C,OAAlCvB,EAAM1C,EAAMC,QAAQE,UACrEyD,MAAO5D,EAAMC,QAAQE,UAEvB,CACEgE,GAAIzB,EAAM1C,EAAMC,QAAQI,YAAc4D,GAA6C,OAAjCvB,EAAM1C,EAAMC,QAAQC,SACtE0D,MAAO5D,EAAMC,QAAQC,UAIekE,QAAO,SAACC,GAAD,OAASA,EAAIF,MACtDG,EAAiBC,IAAOL,GAC9B,OAAII,EACK,CAAEhB,KAAM,SAAUO,OAAQS,EAAeV,OAG3C,CAAEN,KAAM,oBApGd,cAuGJJ,GAAoBK,YAAO,CAC1BX,UAAW,YAAgB,IAAbF,EAAY,EAAZA,MAQN8B,EAPU,CACd,CAAEC,MAAO/B,EAAM1C,EAAMC,QAAQC,SAAU0D,MAAO5D,EAAMC,QAAQC,SAC5D,CAAEuE,MAAO/B,EAAM1C,EAAMC,QAAQE,UAAWyD,MAAO5D,EAAMC,QAAQE,UAC7D,CAAEsE,MAAO/B,EAAM1C,EAAMC,QAAQG,SAAUwD,MAAO5D,EAAMC,QAAQG,SAC5D,CAAEqE,MAAO/B,EAAM1C,EAAMC,QAAQI,UAAWuD,MAAO5D,EAAMC,QAAQI,WAG3B+D,QAAO,SAACM,GAAD,OAA6B,OAAjBA,EAAOD,SACxDE,EAAaJ,IAAOC,GAC1B,OAAIG,EACK,CAAErB,KAAM,SAAUO,OAAQc,EAAWf,OAGvC,CAAEN,KAAM,oBAtHd,cAyHJJ,GAAkBK,YAAO,CACxBX,UAAW,YAAgB,IAAbF,EAAY,EAAZA,MAQNkC,EAPQ,CACZ,CAAEH,MAAO/B,EAAM1C,EAAMM,MAAMC,KAAMqD,MAAO5D,EAAMM,MAAMC,KACpD,CAAEkE,MAAO/B,EAAM1C,EAAMM,MAAME,MAAOoD,MAAO5D,EAAMM,MAAME,MACrD,CAAEiE,MAAO/B,EAAM1C,EAAMM,MAAMG,OAAQmD,MAAO5D,EAAMM,MAAMG,OACtD,CAAEgE,MAAO/B,EAAM1C,EAAMM,MAAMI,KAAMkD,MAAO5D,EAAMM,MAAMI,MAGtB0D,QAAO,SAACS,GAAD,OAAyB,OAAfA,EAAKJ,SAChDK,EAAWP,IAAOK,GACxB,OAAIE,EACK,CAAExB,KAAM,SAAUO,OAAQiB,EAASlB,OAGrC,CAAEN,KAAM,oBAxId,MAmJb,SAASS,GAAWrB,EAAqBb,GACvC,IAAMkD,EDtTD,SAA8BrC,EAAqBb,GACxD,IAAMoC,EAAWrC,GAAYC,GAiB7B,OAhBkB7B,EAAMY,aAAaoE,MAAK,SAACC,GAazC,OAA8B,IAZHA,EAAIC,QAAe,SAACC,EAAKvB,GAClD,OAAIlB,EAAMkB,KAAW/B,EACZsD,EAAM,EAGXzC,EAAMkB,KAAWK,EACZkB,EAAM,EAGRA,IACN,MCySeC,CAAqB1C,EAAOb,GAC1CgC,EAAM,OAAGkB,QAAH,IAAGA,OAAH,EAAGA,EAAaC,MAAK,SAACpB,GAAD,OAA4B,OAAjBlB,EAAMkB,MAClD,YAAeyB,IAAXxB,EACK,CAAEP,KAAM,SAAUO,UAGpB,CAAEP,KAAM,gBAGjB,SAASU,GAAWtB,EAAqBb,GACvC,IAAMyD,ED3SD,SACL5C,EACAb,GAYA,IAAM0D,EAAqB,SAACC,GAa1B,OAAwB,IAZHA,EAAKN,QAAe,SAACC,EAAKvB,GAC7C,OAAIlB,EAAMkB,KAAW/B,EACZsD,EAAM,EAGM,OAAjBzC,EAAMkB,GACDuB,EAGFA,EAAM,IACZ,IAKCtE,EAAOhB,EAAKuE,OAAOmB,GACnBzE,EAAUhB,EAAQsE,OAAOmB,GACzBxE,EAAYhB,EAAUqE,OAAOmB,GAGnC,GAAI1E,EAAK4E,OAAQ,CAAC,IAAD,iBACG5E,GADH,IACf,2BAAwB,CAAC,IAAD,EAAboE,EAAa,uBACFA,GADE,IACtB,2BAAyB,CAAC,IAAD,EAAdrB,EAAc,uBAEF9C,GAFE,IAEvB,2BAA8B,CAAC,IACvB4E,EAAe9B,KADO,QAEtB+B,EAAqC,OAAjBjD,EAAMkB,GAChC,GAAI8B,GAAgBC,EAClB,MAAO,CACLC,kBAAmBhC,IAPF,mDAaJ7C,GAbI,IAavB,2BAA8B,CAAC,IACvB2E,EAAe9B,KADO,QAEtB+B,EAAqC,OAAjBjD,EAAMkB,GAChC,GAAI8B,GAAgBC,EAClB,MAAO,CACLC,kBAAmBhC,IAlBF,gCADH,gCADT,+BA6BjB,GAAI9C,EAAQ2E,OAAQ,CAAC,IAAD,iBACG3E,GADH,IAClB,2BAA8B,CAAC,IAAD,EAAnB+E,EAAmB,uBACRA,GADQ,IAC5B,2BAA4B,CAAC,IAAD,EAAjBjC,EAAiB,uBAGP7C,GAHO,IAG1B,2BAA8B,CAAC,IACvB2E,EAAe9B,KADO,QAEtB+B,EAAqC,OAAjBjD,EAAMkB,GAChC,GAAI8B,GAAgBC,EAClB,MAAO,CACLC,kBAAmBhC,IARC,gCADA,gCADZ,+BAmBpB,OAAyB,IAArB7C,EAAU0E,QAAwC,OAAxB/C,EAAM1C,EAAMW,QACjC,CAAEiF,kBAAmB5F,EAAMW,QAG7B,KCoNMmF,CAAUpD,EAAOb,GAC9B,OAAIyD,EACK,CAAEhC,KAAM,SAAUO,OAAQyB,EAAKM,mBAGjC,CAAEtC,KAAM,gBClVV,I,mDAAMyC,GACA,cADAA,GAEF,YAFEA,GAGQ,uBAHRA,GAIe,8BAJfA,GAKY,0BAaZC,GACA,YADAA,GAEG,eAFHA,GAGS,qBAHTA,GAIA,YAJAA,GAKC,aALDA,GAMD,WANCA,GAOI,gBAPJA,GAQC,aARDA,GASa,yBATbA,GAUgB,4BAGhBC,GACC,aADDA,GAEI,gBCfXC,GAAmC,CACvCC,qBAAsBjF,EAAkBE,QACxCgF,WAAS,qBACNzG,EAAqB,CAAE2D,KAAM5D,EAAkBmC,OAAQjC,IADjD,eAEND,EAAqB,CAAE2D,KAAM5D,EAAkBmC,OAAQjC,IAFjD,IAITyG,UAAW,CACTC,QAAS3G,EACT4G,UAAW,GAEb7D,MAAO1B,EACPwF,SAAU,KACVC,YAAa,MAUFC,GAAmBlE,YAC9B,CACEC,QAASyD,GACTrD,QAASb,GACTc,QAAM,qBAIHd,GAAc,CACbe,IAAE,qBACCC,EAAoB,CAAEC,QAAS,CAACC,MADjC,eAECF,EAAuB,CAAEC,QAAS,CAACC,MAFpC,eAGCF,EAA6B,CAAEC,QAAS,CAACC,MAH1C,eAICF,EAAgB,CACfjB,OAAQC,KALV,MALA,eAiBHA,GAAY,CACXa,QAASb,GACTc,QAAM,qBAKHd,GAAsB,CACrBoB,MAAOF,GACPH,IAAE,qBACCC,EAAkB,CACjB,CACEjB,OAAQC,GACRiB,QAAS,CAACC,GAAYA,IACtBjB,KAAMC,IAER,CACEH,OAAQC,MARZ,eAWCgB,EAAc,CACbjB,OAAO,IAAD,OAAMC,IACZiB,QAAS,CAACC,MAbZ,MAPA,eA4BHlB,GAA6B,CAC5BoB,MAAOF,GACPyD,OAAQ,CACN,CACE5E,OAAO,IAAD,OAAMC,IACZC,KAAMC,IAER,CACEH,OAAQC,OApCV,MAnBJ,eAiEHA,GAA0B,CACzB4E,GAAI5E,GACJe,IAAE,qBACCC,EAAa,CACZjB,OAAQC,GACRiB,QAAS,CAACC,MAHZ,eAKCF,EAAiB,CAChBjB,OAAQC,GACRiB,QAAS,CAACC,MAPZ,MAnEA,KAgFR,CACEG,QAAM,qBACHnB,IAAe,WAAYuB,GAAW,IAApBf,EAAmB,EAAnBA,MACjB,OAAIe,EAAMH,OAASN,GACa,OAAvBN,EAAMe,EAAMG,UAHnB,eAOH1B,IAAkB,YAA2C,IAAxCsE,EAAuC,EAAvCA,SAAUC,EAA6B,EAA7BA,YAAaJ,EAAgB,EAAhBA,UAC3C,OAAOQ,QAAQL,GAAYC,IAAwC,IAAxBJ,EAAUE,aARnD,IAWNtD,SAAO,qBAIJC,GAA2BK,YAAO,eAAK2C,MAJnC,eAKJhD,GAA8BK,aAAO,SAACnB,GAAD,mBAAC,eAClC8D,IADiC,IAEpCE,UAAWhE,EAAIgE,UACfD,qBAAsB/D,EAAI+D,2BARvB,eAcJjD,GAAcK,YAAO,CACpB6C,UAAW,SAAChE,EAAKqB,GACf,GAAIA,EAAMH,OAASN,EAAmB,CAEpC,IACkD,IAD5C8D,EAAmC1E,EAAIgE,UAAU3C,EAAMsD,MAC7D,GAAID,EAAkBxD,OAAS5D,EAC7B,aAAAoH,EAAkBE,KAAIC,YAAtB,iBAIF,IAAMC,EACAzD,EAAMsD,OAASpH,EACyDC,EAIFA,EAItEuH,EACJ1D,EAAMgB,QAAU/E,EACZ,CACE4D,KAAM5D,EACNmC,OAAQqF,GAEV,CACE5D,KAAM5D,EACNsH,IAAKI,YAAM9E,GAAqB4E,GAAkB,CAAEG,KAAM5D,EAAMsD,OAChElF,OAAQqF,GAGhB,OAAO,2BACF9E,EAAIgE,WADT,kBAEG3C,EAAMsD,KAAOI,IAIlB,OAAO/E,EAAIgE,cApDV,eA2DJlD,GAAiBK,YAAO,CACvB8C,UAAW,SAACjE,EAAKqB,GACf,OAAIA,EAAMH,OAASN,EACV,2BACFZ,EAAIiE,WADT,IAEEC,QAAS7C,EAAM6D,QAIZlF,EAAIiE,cApEV,eA2EJnD,GAAuBK,YAAO,CAC7B4C,qBAAsB,SAAC/D,EAAKqB,GAC1B,OAAIA,EAAMH,OAASN,EACVS,EAAMtB,MAGRC,EAAI+D,yBAjFV,eAwFJjD,IAAc,SAACd,GACd,IAAMO,EAASP,EAAIgE,UAAUhE,EAAIiE,UAAUC,SACvC3D,EAAOW,OAAS5D,GAClBiD,EAAOqE,IAAIO,KAAK,CACdjE,KAAMK,EACNjB,MAAON,EAAIM,MACXC,OAAQP,EAAIiE,UAAUC,QACtBjE,gBAAiBD,EAAI+D,0BA/FtB,eAyGJjD,GAAaK,YAAO,CACnBb,MAAO,SAACN,EAAKqB,GACX,GAAIA,EAAMH,OAASN,EAAiB,CAClC,IAAMwE,EAAsB,YAAOpF,EAAIM,OACjC+E,EAAYrF,EAAIgE,UAAU3C,EAAMK,QAAQjC,OAE9C,OADA2F,EAAS/D,EAAMG,OAAS6D,EACjBD,EAGT,OAAOpF,EAAIM,UAlHV,eAyHJQ,GAAkBK,YAAO,CACxBkD,YAAa,SAACrE,GACZ,OAAOA,EAAIiE,UAAUC,YA3HpB,eA+HJpD,GAAeK,YAAO,CACrBiD,SAAU,YAA0B,IAAvB9D,EAAsB,EAAtBA,MAAO8D,EAAe,EAAfA,SACZkB,EAAY1H,EAAMY,aAAaoE,MAAK,SAACD,GAAiB,IAAD,cACvCA,EADuC,GAClD4C,EADkD,KAC/CC,EAD+C,KAC5CC,EAD4C,KAEzD,SAAInF,EAAMiF,IAAMjF,EAAMiF,KAAOjF,EAAMkF,IAAMlF,EAAMiF,KAAOjF,EAAMmF,OAMxDC,EAAepF,EAAMqF,MAAK,SAACC,GAAD,OAA6B,OAAdA,KAC/C,OAAIN,IAAcI,EACTJ,EAEFlB,MA7IN,eAoJJtD,GAAeK,YAAO,CACrB8C,UAAW,SAACjE,GAAD,mBAAC,eACPA,EAAIiE,WADE,IAETC,QAASlE,EAAIiE,UAAUC,UAAY3G,EAAqBA,EAAqBA,EAC7E4G,UAAWnE,EAAIiE,UAAUE,UAAY,QAxJpC,MCxIE0B,GAAaC,IAAOC,OAAV,wF,QCUjBC,GAAgBF,IAAOG,IAAV,6DAKbC,GAAwBJ,IAAOK,OAAV,kDAIrBC,GAAuBC,OAAOC,OAAOxH,GACxCyH,MAAK,SAAChB,EAAGC,GAAJ,OAAWD,EAAIC,EAAI,GAAK,KAC7BgB,KAAI,SAACzG,GAAD,OACH,0BAAoBsC,MAAOtC,EAA3B,UACGA,EADH,OAAaA,MAYJ0G,GAAgE,SAAC,GAAc,IAAZtB,EAAW,EAAXA,KAwC9E,OACE,gBAACa,GAAD,WACE,eAACH,GAAD,CAAY3E,KAAK,SAASwF,QAvCT,kBAAMvB,EAAK,CAAEjE,KAAMN,KAuCpC,8BAGA,eAACiF,GAAD,CAAY3E,KAAK,SAASwF,QAtCT,WACnBvB,EAAK,CACHjE,KAAMN,EACN+D,KAAMpH,EACN8E,MAAO/E,IAET6H,EAAK,CAAEjE,KAAMN,KAgCX,0BAGA,eAACiF,GAAD,CAAY3E,KAAK,SAASwF,QA9BT,WACnBvB,EAAK,CACHjE,KAAMN,EACN+D,KAAMpH,EACN8E,MAAO/E,IAET6H,EAAK,CACHjE,KAAMN,EACN+D,KAAMpH,EACN8E,MAAO/E,IAET6H,EAAK,CAAEjE,KAAMN,KAmBX,sBAGA,uDACoB,wBADpB,sCAGA,eAACsF,GAAD,CAAuBS,aAAc7H,EAAkBE,QAAS4H,SArBhD,SAACC,GACnB1B,EAAK,CACHjE,KAAMN,EACNb,MAAO+G,OAAOD,EAAElH,OAAO0C,UAkBvB,SACG+D,KAEH,8DAC2B,wBAD3B,mCACiE,wBADjE,2BC3FOW,GAAmB,aCG1BC,GAAYlB,IAAOG,IAAV,oJAYTgB,GAAYnB,IAAOG,IAAV,uOAOO,YAAqE,IAAlEiB,EAAiE,EAAjEA,YAAaC,EAAoD,EAApDA,cAAe/C,EAAqC,EAArCA,SAAUwB,EAA2B,EAA3BA,UAAWwB,EAAgB,EAAhBA,UAEtE,OAAIhD,EACKA,EAASiD,SAASD,GAAa,aAAUnE,EAITkE,GAAiBC,IAAcxJ,EAAMW,QAAwB,OAAdqH,GACvDuB,IAAkBD,GAA6B,OAAdtB,EAEzD,eADT,KAsBS0B,GAAgDC,IAAMC,MACjE,YAAmE,IAAhElH,EAA+D,EAA/DA,MAAOmH,EAAwD,EAAxDA,YAAaP,EAA2C,EAA3CA,YAAaC,EAA8B,EAA9BA,cAAe/C,EAAe,EAAfA,SACjD,OACE,eAAC4C,GAAD,UACG1G,EAAMkG,KAAI,SAACZ,EAAWpE,GACrB,IAAM4F,EAAY5F,EAClB,OACE,eAACyF,GAAD,CAIES,KAAK,SACLC,SAAUP,EACVQ,UAAWb,GACXG,YAAaA,EACbC,cAAeA,EACf/C,SAAUA,EACVgD,UAAWA,EACXxB,UAAWA,EACXc,QAAO,OAAEe,QAAF,IAAEA,OAAF,EAAEA,EAAcL,GAZzB,SAcGxB,GAXIwB,WC/DNS,GAAgB/B,IAAOG,IAAV,8DAKb6B,GAAmBhC,IAAOiC,GAAV,4BCchBC,GAA4D,SAAC,GAA4B,IAA1B7C,EAAyB,EAAzBA,KAAM8C,EAAmB,EAAnBA,aAC1EC,EAAgBD,EAAa5H,QAAQ4D,UAAUC,QACrCiE,EAAwBF,EAAa5H,QAAQ2D,UAAUkE,GAA/DzI,OACF0H,EAAgBc,EAAa5H,QAAQ2D,UAAUkE,GAAehH,OAAS5D,EACvE4J,EAA2D,IAA7Ce,EAAa5H,QAAQ4D,UAAUE,UAE7CiE,EAAWb,IAAMc,SAAQ,WAC7B,OAAOlB,EACH,SAAC3F,GAAD,OAA2B,WACzB2D,EAAK,CACHjE,KAAMN,EACNY,QACAE,OAAQwG,MAGZ,kBAAMnB,MACT,CAACI,IAEJ,OACE,gBAACU,GAAD,WACE,eAACC,GAAD,oBAAsBI,EAAtB,aAAwCC,EAAxC,oBACA,eAACb,GAAD,CACEhH,MAAO2H,EAAa5H,QAAQC,MAC5BmH,YAAaW,EACblB,YAAaA,EACbC,cAAeA,IAEhBA,EACC,eAACtB,GAAD,CAAY3E,KAAK,SAASwF,QAAS,kBAAMvB,EAAK,CAAEjE,KAAMN,KAAtD,qBAIA,eAACiF,GAAD,CAAY3E,KAAK,SAASoH,UAAQ,EAAlC,qBC9CFC,GAAmBzC,IAAOG,IAAV,4BAOTuC,GAAkE,SAAC,GAA4B,IAA1BrD,EAAyB,EAAzBA,KAAM8C,EAAmB,EAAnBA,aAAmB,EACvEA,EAAa5H,QAAvC+D,EADiG,EACjGA,SAAUC,EADuF,EACvFA,YAElB,OACE,gBAACwD,GAAD,WACE,eAACC,GAAD,yBACA,eAACR,GAAD,CAAgBhH,MAAO2H,EAAa5H,QAAQC,MAAO8D,SAAU6D,EAAa5H,QAAQ+D,WAClF,eAACyB,GAAD,CAAY3E,KAAK,SAASwF,QAAS,kBAAMvB,EAAK,CAAEjE,KAAMN,KAAtD,mBAGA,eAACiF,GAAD,CAAY3E,KAAK,SAASwF,QAAS,kBAAMvB,EAAK,CAAEjE,KAAMN,KAAtD,sBAICwD,GAAY,eAACmE,GAAD,oCAAsCnE,KAClDC,GAAe,eAACkE,GAAD,oBAAsBlE,EAAtB,oBACdD,IAAaC,GAAe,eAACkE,GAAD,8BCrBpCE,YAAQ,CAAEC,OAAQ,kBAAMC,SAASC,eAAe,oBAEhD,IAAMC,GAAyB/C,IAAOG,IAAV,8JAQf6C,GAA0B,WAAO,IAAD,EACdC,YAAWzE,GAAkB,CAAE0E,UAAU,IAD3B,mBACpCf,EADoC,KACtB9C,EADsB,KAgC3C,OAXA8D,qBAAU,WAGRC,QAAQC,IAAI,CACVC,KAAMnB,EAAa5H,QAAQ4D,UAAUE,UACrC9D,QAAS4H,EAAa5H,QACtBgJ,OAAQpB,EAAaoB,OACrBhH,MAAO4F,EAAa5F,WAIjB,eAACwG,GAAD,UA9BoB,WACzB,QAAQ,GACN,KAAKZ,EAAaqB,QAAQ1J,IACxB,OAAO,eAAC,GAAD,CAAwBuF,KAAMA,IAGvC,KAAK8C,EAAaqB,QAAQ1J,IACxB,OAAO,eAAC,GAAD,CAAsBuF,KAAMA,EAAM8C,aAAcA,IAGzD,KAAKA,EAAaqB,QAAQ1J,IACxB,OAAO,eAAC,GAAD,CAAyBuF,KAAMA,EAAM8C,aAAcA,IAG5D,QACE,OAAO,kDAemBsB,MCjDrBC,GAAgB,WAC3B,OAAO,eAAC,GAAD,KCKTC,IAASC,OACP,eAAC,IAAMC,WAAP,UACE,eAAC,GAAD,MAEFhB,SAASC,eAAe,SAM1B/L,M","file":"static/js/main.66d22cb3.chunk.js","sourcesContent":["// eslint-disable-next-line\n// @ts-ignore\nimport { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { ActorRef } from 'xstate';\n\nexport const PLAYER_TYPE = {\n  user: 'user',\n  agent: 'agent',\n} as const;\n\nexport type PlayerContext =\n  | { type: typeof PLAYER_TYPE.user }\n  | {\n      type: typeof PLAYER_TYPE.agent;\n      ref: ActorRef<TicTacToeActorEvents>;\n    };\n\nexport const PLAYER_NUM = {\n  player1: 'player1',\n  player2: 'player2',\n} as const;\n\nexport type PlayerTurnContext = typeof PLAYER_NUM[keyof typeof PLAYER_NUM];\n\nexport const PLAYER_SYMBOL = {\n  x: 'x',\n  o: '0',\n} as const;\n\nexport type PlayerFieldSymbol = typeof PLAYER_SYMBOL[keyof typeof PLAYER_SYMBOL];\n\nexport type FieldCellValue = PlayerFieldSymbol | null;\nexport type FieldCellIndex = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n\n// strictly 9 cells\nexport type FieldContext = [\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n];\n\nexport const ROWS: FieldCellIndex[][] = [\n  [0, 1, 2],\n  [3, 4, 5],\n  [6, 7, 8],\n];\n\nexport const COLUMNS: FieldCellIndex[][] = [\n  [0, 3, 6],\n  [1, 4, 7],\n  [2, 5, 8],\n];\n\nexport const DIAGONALS: FieldCellIndex[][] = [\n  [0, 4, 8],\n  [2, 4, 6],\n];\n\nexport const FIELD = {\n  corners: {\n    topLeft: 0 as FieldCellIndex,\n    topRight: 2 as FieldCellIndex,\n    botLeft: 6 as FieldCellIndex,\n    botRight: 8 as FieldCellIndex,\n  },\n  edges: {\n    top: 1 as FieldCellIndex,\n    left: 3 as FieldCellIndex,\n    right: 5 as FieldCellIndex,\n    bot: 7 as FieldCellIndex,\n  },\n  center: 4 as FieldCellIndex,\n  combinations: [...ROWS, ...COLUMNS, ...DIAGONALS],\n  rows: ROWS,\n  columns: COLUMNS,\n  diagonals: DIAGONALS,\n};\n\nexport const FIELD_INITIAL: FieldContext = [null, null, null, null, null, null, null, null, null];\n\nexport const TTT_EVENT_TYPE = {\n  changePlayerReq: 'changePlayerReq',\n  continueReq: 'continueReq',\n  changeTurnOrderReq: 'changeTurnOrderReq',\n  changeTransitionDelayReq: 'changeTransitionDelayReq',\n  acceptTurnReq: 'acceptTurnReq',\n  giveUpReq: 'giveUpReq',\n  retryReq: 'retryReq',\n  setUpNewGame: 'setUpNewGame',\n} as const;\n\nexport type TicTacToeEvents =\n  | { type: typeof TTT_EVENT_TYPE.changePlayerReq; kind: PlayerTurnContext; value: PlayerContext['type'] }\n  | { type: typeof TTT_EVENT_TYPE.continueReq }\n  | { type: typeof TTT_EVENT_TYPE.changeTurnOrderReq; first: PlayerTurnContext }\n  | { type: typeof TTT_EVENT_TYPE.changeTransitionDelayReq; delay: TicTacToeTransitionDelay }\n  | { type: typeof TTT_EVENT_TYPE.acceptTurnReq; index: FieldCellIndex; sender: PlayerTurnContext }\n  | { type: typeof TTT_EVENT_TYPE.giveUpReq }\n  | { type: typeof TTT_EVENT_TYPE.retryReq }\n  | { type: typeof TTT_EVENT_TYPE.setUpNewGame };\n\nexport const TTT_DELAY_OPTIONS = {\n  0: 0,\n  default: 300,\n  500: 500,\n  700: 700,\n  1000: 1000,\n} as const;\n\nexport type TicTacToeTransitionDelay = typeof TTT_DELAY_OPTIONS[keyof typeof TTT_DELAY_OPTIONS];\n\nexport type TicTacToeContext = {\n  actorTransitionDelay: TicTacToeTransitionDelay;\n\n  opponents: {\n    [PLAYER_NUM.player1]: PlayerContext & { symbol: Extract<PlayerFieldSymbol, typeof PLAYER_SYMBOL.x> };\n    [PLAYER_NUM.player2]: PlayerContext & { symbol: Extract<PlayerFieldSymbol, typeof PLAYER_SYMBOL.o> };\n  };\n\n  turnOrder: {\n    current: PlayerTurnContext;\n    turnsMade: number;\n  };\n\n  field: FieldContext;\n\n  winCombo: [FieldCellIndex, FieldCellIndex, FieldCellIndex] | null;\n  surrendered: PlayerTurnContext | null;\n};\n\nexport const TTT_ACTOR_EVENT_TYPE = {\n  makeTurnReq: 'makeTurnReq',\n} as const;\n\n// Machine to Actor -- Msg\nexport type TicTacToeActorEvents = {\n  type: typeof TTT_ACTOR_EVENT_TYPE.makeTurnReq;\n  field: FieldContext;\n  player: PlayerTurnContext;\n  transitionDelay: TicTacToeTransitionDelay;\n};\n","import {\n  PlayerFieldSymbol,\n  FieldCellIndex,\n  TicTacToeContext,\n  PlayerTurnContext,\n  TicTacToeTransitionDelay,\n} from './TicTacToe.common';\n\nexport type TicTacToeActorContext = {\n  field: TicTacToeContext['field'];\n  player: PlayerTurnContext;\n  symbol: PlayerFieldSymbol;\n  moveReady: { type: 'commit'; turnTo: FieldCellIndex } | { type: 'tryOtherMove' } | null;\n  transitionDelay: TicTacToeTransitionDelay;\n};\n\nexport const TTT_ACTOR_STATE = {\n  awaitingTurn: '@/awaitingTurn',\n  makingTurn: '@/makingTurn',\n  tryingToWin: '@/tryingToWin',\n  tryingToBlockWin: '@/tryingToBlockWin',\n  tryingToFork: '@/tryingToFork',\n  tryingToBlockFork: '@/tryingToBlockFork',\n  tryingToTakeCenter: '@/tryingToTakeCenter',\n  tryingToTakeOppositeCorner: '@/tryingToTakeOppositeCorner',\n  tryingToTakeCorner: '@/tryingToTakeCorner',\n  tryingToTakeEmptySide: '@/tryingToTakeEmptySide',\n  givingUp: '@/givingUp',\n} as const;\n\nexport type TicTacToeActorState = {\n  context: TicTacToeActorContext;\n  value:\n    | typeof TTT_ACTOR_STATE.awaitingTurn\n    | typeof TTT_ACTOR_STATE.makingTurn\n    | typeof TTT_ACTOR_STATE.tryingToWin\n    | typeof TTT_ACTOR_STATE.tryingToBlockWin\n    | typeof TTT_ACTOR_STATE.tryingToFork\n    | typeof TTT_ACTOR_STATE.tryingToBlockFork\n    | typeof TTT_ACTOR_STATE.tryingToTakeCenter\n    | typeof TTT_ACTOR_STATE.tryingToTakeOppositeCorner\n    | typeof TTT_ACTOR_STATE.tryingToTakeCorner\n    | typeof TTT_ACTOR_STATE.tryingToTakeEmptySide\n    | typeof TTT_ACTOR_STATE.givingUp;\n};\n\nexport const TTT_ACTOR_GUARD = {\n  verifyTurnReady: 'verifyTurnReady',\n} as const;\n\nexport const TTT_ACTOR_ACTION = {\n  saveField: 'saveField',\n  makeTurn: 'makeTurn',\n  tryWinning: 'tryWinning',\n  tryBlockingWin: 'tryBlockingWin',\n  tryForking: 'tryForking',\n  tryBlockingFork: 'tryBlockingFork',\n  tryTakingCenter: 'tryTakingCenter',\n  tryTakingOppositeCorner: 'tryTakingOppositeCorner',\n  tryTakingCorner: 'tryTakingCorner',\n  tryTakingSide: 'tryTakingSide',\n  giveUp: 'giveUp',\n} as const;\n","import {\n  PlayerFieldSymbol,\n  PLAYER_SYMBOL,\n  FieldContext,\n  FIELD,\n  FieldCellIndex,\n  ROWS,\n  COLUMNS,\n  DIAGONALS,\n} from './TicTacToe.common';\n\nexport function getOpponent(symbol: PlayerFieldSymbol): PlayerFieldSymbol {\n  return symbol === PLAYER_SYMBOL.x ? PLAYER_SYMBOL.o : PLAYER_SYMBOL.x;\n}\n\nexport function find2InARowWith1Free(field: FieldContext, symbol: PlayerFieldSymbol): FieldCellIndex[] | undefined {\n  const opponent = getOpponent(symbol);\n  const twoInARow = FIELD.combinations.find((row) => {\n    const actorSymbolsInARow = row.reduce<number>((acc, index) => {\n      if (field[index] === symbol) {\n        return acc + 1;\n      }\n\n      if (field[index] === opponent) {\n        return acc - 1;\n      }\n\n      return acc;\n    }, 0);\n\n    return actorSymbolsInARow === 2;\n  });\n\n  return twoInARow;\n}\n\nexport function findAFork(\n  field: FieldContext,\n  symbol: PlayerFieldSymbol,\n): { intersectionIndex: FieldCellIndex } | null {\n  // if there are two intersecting rows, columns, or diagonals\n  // with one of my pieces and two blanks,\n  // =====================================\n  //  [*,X,*]\n  //  [X,_,_] <- 2 blanks on row 2\n  //  [*,_,*]\n  //     ^- 2 blanks on col 2\n  //  cell 4 (center) is an intersection\n  // =====================================\n  // and if the intersecting space is empty\n  const oneTakenAnd2Blanks = (line: FieldCellIndex[]) => {\n    const howManyTaken = line.reduce<number>((acc, index) => {\n      if (field[index] === symbol) {\n        return acc + 1;\n      }\n\n      if (field[index] === null) {\n        return acc;\n      }\n\n      return acc - 1;\n    }, 0);\n\n    return howManyTaken === 1;\n  };\n\n  const rows = ROWS.filter(oneTakenAnd2Blanks);\n  const columns = COLUMNS.filter(oneTakenAnd2Blanks);\n  const diagonals = DIAGONALS.filter(oneTakenAnd2Blanks);\n\n  // scanning rows-first\n  if (rows.length) {\n    for (const row of rows) {\n      for (const index of row) {\n        // against columns\n        for (const column of columns) {\n          const intersection = index in column;\n          const intersectionEmpty = field[index] === null;\n          if (intersection && intersectionEmpty) {\n            return {\n              intersectionIndex: index,\n            };\n          }\n        }\n\n        // against diagonals\n        for (const diag of diagonals) {\n          const intersection = index in diag;\n          const intersectionEmpty = field[index] === null;\n          if (intersection && intersectionEmpty) {\n            return {\n              intersectionIndex: index,\n            };\n          }\n        }\n      }\n    }\n  }\n\n  // scanning columns-first\n  if (columns.length) {\n    for (const column of columns) {\n      for (const index of column) {\n        // against diagonals\n        // (already scanned against rows if they were available)\n        for (const diag of diagonals) {\n          const intersection = index in diag;\n          const intersectionEmpty = field[index] === null;\n          if (intersection && intersectionEmpty) {\n            return {\n              intersectionIndex: index,\n            };\n          }\n        }\n      }\n    }\n  }\n\n  // 2 diagonals can only intersect in the center\n  if (diagonals.length === 2 && field[FIELD.center] === null) {\n    return { intersectionIndex: FIELD.center };\n  }\n\n  return null;\n}\n","import { createMachine, StateMachine, assign, sendParent, Expr } from 'xstate';\n\nimport sample from 'lodash.sample';\n\nimport {\n  TicTacToeActorEvents,\n  TTT_ACTOR_EVENT_TYPE as E,\n  TTT_EVENT_TYPE as Msg,\n  TicTacToeEvents,\n  FIELD_INITIAL,\n  PlayerFieldSymbol,\n  TTT_EVENT_TYPE,\n  FIELD,\n  FieldContext,\n  PLAYER_NUM,\n  TTT_DELAY_OPTIONS,\n} from './TicTacToe.common';\nimport {\n  TicTacToeActorContext,\n  TicTacToeActorState,\n  TTT_ACTOR_ACTION as A,\n  TTT_ACTOR_GUARD as G,\n  TTT_ACTOR_STATE as S,\n} from './TicTacToe.actor.types';\nimport { getOpponent, find2InARowWith1Free, findAFork } from './TicTacToe.actor.business';\n\nconst MSG_DELAY = 300;\n\nconst MAKING_TURN_ACTION = {\n  target: S.makingTurn,\n  cond: G.verifyTurnReady,\n  delay: ((ctx) => ctx.transitionDelay) as Expr<TicTacToeActorContext, TicTacToeActorEvents, number>,\n} as const;\n\n/**\n * This machine defines actor' states using\n * Newell and Simon's expert model with rule ordering:\n *\n * - https://en.wikipedia.org/wiki/Tic-tac-toe#Combinatorics\n * - https://en.wikipedia.org/wiki/Tic-tac-toe#Strategy\n * - https://doi.org/10.1016%2F0364-0213%2893%2990003-Q\n */\nexport const createTicTacToeActor = (\n  givenSymbol: PlayerFieldSymbol,\n): StateMachine<TicTacToeActorContext, Record<string, unknown>, TicTacToeActorEvents, TicTacToeActorState> =>\n  createMachine<TicTacToeActorContext, TicTacToeActorEvents, TicTacToeActorState>(\n    {\n      context: {\n        field: FIELD_INITIAL,\n        player: PLAYER_NUM.player2,\n        symbol: givenSymbol,\n        moveReady: null,\n        transitionDelay: TTT_DELAY_OPTIONS.default,\n      },\n      initial: S.awaitingTurn,\n      states: {\n        [S.awaitingTurn]: {\n          on: {\n            [E.makeTurnReq]: {\n              target: S.tryingToWin,\n              actions: [A.saveField],\n            },\n          },\n        },\n\n        [S.makingTurn]: {\n          /**\n           * NOTE: I'm only adding transition delay for educational purposes\n           *       so we could clearly see in inspector what's happening with the actor.\n           *\n           * Otherwise, I'd be using `always` instead of `after`.\n           */\n          after: [\n            {\n              target: S.awaitingTurn,\n              actions: A.makeTurn,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n\n        [S.tryingToWin]: {\n          entry: A.tryWinning,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToBlockWin,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToBlockWin]: {\n          entry: A.tryBlockingWin,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToFork,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToFork]: {\n          entry: A.tryForking,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToBlockFork,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToBlockFork]: {\n          entry: A.tryBlockingFork,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToTakeCenter,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToTakeCenter]: {\n          entry: A.tryTakingCenter,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToTakeOppositeCorner,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToTakeOppositeCorner]: {\n          entry: A.tryTakingOppositeCorner,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToTakeCorner,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToTakeCorner]: {\n          entry: A.tryTakingCorner,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToTakeEmptySide,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToTakeEmptySide]: {\n          entry: A.tryTakingSide,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.givingUp,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n\n        [S.givingUp]: {\n          after: [\n            {\n              target: S.awaitingTurn,\n              actions: A.giveUp,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n      },\n    },\n    {\n      guards: {\n        [G.verifyTurnReady]: ({ moveReady }: TicTacToeActorContext) => moveReady?.type === 'commit',\n      },\n      actions: {\n        /**\n         * CHILD-PARENT Msg ===================================================\n         */\n\n        [A.saveField]: assign({\n          player: (_, event) => event.player,\n          field: (_, event) => event.field,\n          transitionDelay: (_, event) => event.transitionDelay,\n        }),\n\n        [A.makeTurn]: sendParent(\n          ({\n            player,\n            moveReady,\n          }): Extract<\n            TicTacToeEvents,\n            { type: typeof TTT_EVENT_TYPE.acceptTurnReq | typeof TTT_EVENT_TYPE.giveUpReq }\n          > => {\n            if (moveReady?.type === 'commit') {\n              return { type: Msg.acceptTurnReq, index: moveReady.turnTo, sender: player };\n            }\n\n            return { type: Msg.giveUpReq };\n          },\n          { delay: MSG_DELAY },\n        ),\n\n        [A.giveUp]: sendParent(\n          (): Extract<TicTacToeEvents, { type: typeof TTT_EVENT_TYPE.giveUpReq }> => {\n            return { type: Msg.giveUpReq };\n          },\n          { delay: MSG_DELAY },\n        ),\n\n        /**\n         * ACTOR BUSINESS =====================================================\n         */\n\n        [A.tryWinning]: assign({\n          moveReady: ({ field, symbol }) => {\n            return tryWinning(field, symbol);\n          },\n        }),\n        [A.tryBlockingWin]: assign({\n          moveReady: ({ field, symbol }) => {\n            const opponentSymbol = getOpponent(symbol);\n            return tryWinning(field, opponentSymbol);\n          },\n        }),\n        [A.tryForking]: assign({\n          moveReady: ({ field, symbol }) => {\n            return tryForking(field, symbol);\n          },\n        }),\n        [A.tryBlockingFork]: assign({\n          moveReady: ({ field, symbol }) => {\n            const opponentSymbol = getOpponent(symbol);\n            return tryForking(field, opponentSymbol);\n          },\n        }),\n        [A.tryTakingCenter]: assign({\n          moveReady: ({ field }) => {\n            if (field[FIELD.center] === null) {\n              return { type: 'commit', turnTo: FIELD.center };\n            }\n\n            return { type: 'tryOtherMove' };\n          },\n        }),\n        [A.tryTakingOppositeCorner]: assign({\n          moveReady: ({ field, symbol }) => {\n            const opponent = getOpponent(symbol);\n            // if my opponent is in a corner, and\n            // if the opposite corner is empty\n            const corners = [\n              {\n                is: field[FIELD.corners.topLeft] === opponent && field[FIELD.corners.botRight] === null,\n                index: FIELD.corners.botRight,\n              },\n              {\n                is: field[FIELD.corners.topRight] === opponent && field[FIELD.corners.botLeft] === null,\n                index: FIELD.corners.botLeft,\n              },\n              {\n                is: field[FIELD.corners.botLeft] === opponent && field[FIELD.corners.topRight] === null,\n                index: FIELD.corners.topRight,\n              },\n              {\n                is: field[FIELD.corners.botRight] === opponent && field[FIELD.corners.topLeft] === null,\n                index: FIELD.corners.topLeft,\n              },\n            ];\n\n            const possibleOppositeCorners = corners.filter((inv) => inv.is);\n            const oppositeCorner = sample(possibleOppositeCorners);\n            if (oppositeCorner) {\n              return { type: 'commit', turnTo: oppositeCorner.index };\n            }\n\n            return { type: 'tryOtherMove' };\n          },\n        }),\n        [A.tryTakingCorner]: assign({\n          moveReady: ({ field }) => {\n            const corners = [\n              { value: field[FIELD.corners.topLeft], index: FIELD.corners.topLeft },\n              { value: field[FIELD.corners.topRight], index: FIELD.corners.topRight },\n              { value: field[FIELD.corners.botLeft], index: FIELD.corners.botLeft },\n              { value: field[FIELD.corners.botRight], index: FIELD.corners.botRight },\n            ];\n\n            const possibleFreeCorners = corners.filter((corner) => corner.value === null);\n            const freeCorner = sample(possibleFreeCorners);\n            if (freeCorner) {\n              return { type: 'commit', turnTo: freeCorner.index };\n            }\n\n            return { type: 'tryOtherMove' };\n          },\n        }),\n        [A.tryTakingSide]: assign({\n          moveReady: ({ field }) => {\n            const sides = [\n              { value: field[FIELD.edges.top], index: FIELD.edges.top },\n              { value: field[FIELD.edges.left], index: FIELD.edges.left },\n              { value: field[FIELD.edges.right], index: FIELD.edges.right },\n              { value: field[FIELD.edges.bot], index: FIELD.edges.bot },\n            ];\n\n            const possibleFreeSides = sides.filter((side) => side.value === null);\n            const freeSide = sample(possibleFreeSides);\n            if (freeSide) {\n              return { type: 'commit', turnTo: freeSide.index };\n            }\n\n            return { type: 'tryOtherMove' };\n          },\n        }),\n      },\n    },\n  );\n\n/*\n * COMMON ACTIONS =============================================================\n */\n\nfunction tryWinning(field: FieldContext, symbol: PlayerFieldSymbol): TicTacToeActorContext['moveReady'] {\n  const combination = find2InARowWith1Free(field, symbol);\n  const turnTo = combination?.find((index) => field[index] === null);\n  if (turnTo !== undefined) {\n    return { type: 'commit', turnTo };\n  }\n\n  return { type: 'tryOtherMove' };\n}\n\nfunction tryForking(field: FieldContext, symbol: PlayerFieldSymbol): TicTacToeActorContext['moveReady'] {\n  const fork = findAFork(field, symbol);\n  if (fork) {\n    return { type: 'commit', turnTo: fork.intersectionIndex };\n  }\n\n  return { type: 'tryOtherMove' };\n}\n","import { TicTacToeContext } from './TicTacToe.common';\n\nexport const TTT_STATE = {\n  settingUp: '@/settingUp',\n  playing: '@/playing',\n  playingTakingTurn: '@/playing/takingTurn',\n  playingCheckingGameState: '@/playing/checkingGameState',\n  showingGameEndResults: '@/showingGameEndResults',\n} as const;\n\nexport type TicTacToeState = {\n  context: TicTacToeContext;\n  value:\n    | typeof TTT_STATE.settingUp\n    | typeof TTT_STATE.playing\n    | { playing: typeof TTT_STATE.playingTakingTurn }\n    | { playing: typeof TTT_STATE.playingCheckingGameState }\n    | typeof TTT_STATE.showingGameEndResults;\n};\n\nexport const TTT_ACTION = {\n  setPlayer: 'setPlayer',\n  setTurnOrder: 'setTurnOrder',\n  setTransitionDelay: 'setTransitionDelay',\n  awaitTurn: 'awaitTurn',\n  tryGameEnd: 'tryGameEnd',\n  saveTurn: 'saveTurn',\n  saveSurrender: 'saveSurrender',\n  switchTurn: 'switchTurn',\n  revertContextToInitial: 'revertContextToInitial',\n  revertContextButOpponents: 'revertContextButOpponents',\n} as const;\n\nexport const TTT_GUARD = {\n  verifyTurn: 'verifyTurn',\n  verifyGameEnd: 'verifyGameEnd',\n} as const;\n","import { createMachine, assign, spawn, Interpreter, State } from 'xstate';\n\nimport { createTicTacToeActor } from './TicTacToe.actor';\nimport {\n  TTT_ACTOR_EVENT_TYPE as Msg,\n  PLAYER_TYPE,\n  PlayerContext,\n  FieldContext,\n  FIELD_INITIAL,\n  PLAYER_SYMBOL,\n  TicTacToeEvents,\n  TTT_EVENT_TYPE as E,\n  PLAYER_NUM,\n  TicTacToeContext,\n  FIELD,\n  TTT_DELAY_OPTIONS,\n} from './TicTacToe.common';\n\nimport { TicTacToeState, TTT_STATE as S, TTT_ACTION as A, TTT_GUARD as G } from './TicTacToe.machine.types';\n\nconst initialContext: TicTacToeContext = {\n  actorTransitionDelay: TTT_DELAY_OPTIONS.default,\n  opponents: {\n    [PLAYER_NUM.player1]: { type: PLAYER_TYPE.user, symbol: PLAYER_SYMBOL.x },\n    [PLAYER_NUM.player2]: { type: PLAYER_TYPE.user, symbol: PLAYER_SYMBOL.o },\n  },\n  turnOrder: {\n    current: PLAYER_NUM.player1,\n    turnsMade: 0,\n  },\n  field: FIELD_INITIAL,\n  winCombo: null,\n  surrendered: null,\n};\n\nexport type TicTacToeMachineSend = Interpreter<TicTacToeContext, never, TicTacToeEvents, TicTacToeState>['send'];\n\nexport type TicTacToeMachineState = State<TicTacToeContext, TicTacToeEvents, never, TicTacToeState>;\n\n/**\n * This machine defines major states of the game\n */\nexport const TicTacToeMachine = createMachine<TicTacToeContext, TicTacToeEvents, TicTacToeState>(\n  {\n    context: initialContext,\n    initial: S.settingUp,\n    states: {\n      /**\n       * We need to setup the game: set players; decide turn-order\n       */\n      [S.settingUp]: {\n        on: {\n          [E.changePlayerReq]: { actions: [A.setPlayer] },\n          [E.changeTurnOrderReq]: { actions: [A.setTurnOrder] },\n          [E.changeTransitionDelayReq]: { actions: [A.setTransitionDelay] },\n          [E.continueReq]: {\n            target: S.playing,\n          },\n        },\n      },\n      /**\n       * While playing we will:\n       */\n      [S.playing]: {\n        initial: S.playingTakingTurn,\n        states: {\n          /**\n           * - wait for their turn\n           * - accept or force to turn again\n           */\n          [S.playingTakingTurn]: {\n            entry: A.awaitTurn,\n            on: {\n              [E.acceptTurnReq]: [\n                {\n                  target: S.playingCheckingGameState,\n                  actions: [A.saveTurn, A.switchTurn],\n                  cond: G.verifyTurn,\n                },\n                {\n                  target: S.playingCheckingGameState,\n                },\n              ],\n              [E.giveUpReq]: {\n                target: `#${S.showingGameEndResults}`,\n                actions: [A.saveSurrender],\n              },\n            },\n          },\n          /**\n           * - decide if the game has ended\n           * - or ask other player to move\n           */\n          [S.playingCheckingGameState]: {\n            entry: A.tryGameEnd,\n            always: [\n              {\n                target: `#${S.showingGameEndResults}`,\n                cond: G.verifyGameEnd,\n              },\n              {\n                target: S.playingTakingTurn,\n              },\n            ],\n          },\n        },\n      },\n      /**\n       * We need to show the results\n       * - we should ask if players want to retry\n       */\n      [S.showingGameEndResults]: {\n        id: S.showingGameEndResults,\n        on: {\n          [E.retryReq]: {\n            target: S.playing,\n            actions: [A.revertContextButOpponents],\n          },\n          [E.setUpNewGame]: {\n            target: S.settingUp,\n            actions: [A.revertContextToInitial],\n          },\n        },\n      },\n    },\n  },\n  {\n    guards: {\n      [G.verifyTurn]: ({ field }, event) => {\n        if (event.type === E.acceptTurnReq) {\n          return field[event.index] === null;\n        }\n        return false;\n      },\n      [G.verifyGameEnd]: ({ winCombo, surrendered, turnOrder }) => {\n        return Boolean(winCombo || surrendered) || turnOrder.turnsMade === 9;\n      },\n    },\n    actions: {\n      /**\n       * Reverting context to initial\n       */\n      [A.revertContextToInitial]: assign({ ...initialContext }),\n      [A.revertContextButOpponents]: assign((ctx) => ({\n        ...initialContext,\n        opponents: ctx.opponents,\n        actorTransitionDelay: ctx.actorTransitionDelay,\n      })),\n\n      /**\n       * Setting a player to be controlled by a user or an agent\n       */\n      [A.setPlayer]: assign({\n        opponents: (ctx, event) => {\n          if (event.type === E.changePlayerReq) {\n            // stop old agent if exists\n            const currentPlayerInfo: PlayerContext = ctx.opponents[event.kind];\n            if (currentPlayerInfo.type === PLAYER_TYPE.agent) {\n              currentPlayerInfo.ref.stop?.();\n            }\n\n            // spawn a new one if needed\n            const newPlayerSymbol = (() => {\n              if (event.kind === PLAYER_NUM.player1) {\n                const player1Symbol: TicTacToeContext['opponents']['player1']['symbol'] = PLAYER_SYMBOL.x;\n                return player1Symbol;\n              }\n\n              const player2Symbol: TicTacToeContext['opponents']['player2']['symbol'] = PLAYER_SYMBOL.o;\n              return player2Symbol;\n            })();\n\n            const newPlayerInfo: TicTacToeContext['opponents']['player1'] | TicTacToeContext['opponents']['player2'] =\n              event.value === PLAYER_TYPE.user\n                ? {\n                    type: PLAYER_TYPE.user,\n                    symbol: newPlayerSymbol,\n                  }\n                : {\n                    type: PLAYER_TYPE.agent,\n                    ref: spawn(createTicTacToeActor(newPlayerSymbol), { name: event.kind }),\n                    symbol: newPlayerSymbol,\n                  };\n\n            return {\n              ...ctx.opponents,\n              [event.kind]: newPlayerInfo,\n            };\n          }\n\n          return ctx.opponents;\n        },\n      }),\n\n      /**\n       * Setting who plays on the current turn\n       */\n      [A.setTurnOrder]: assign({\n        turnOrder: (ctx, event) => {\n          if (event.type === E.changeTurnOrderReq) {\n            return {\n              ...ctx.turnOrder,\n              current: event.first,\n            };\n          }\n\n          return ctx.turnOrder;\n        },\n      }),\n\n      /**\n       * Setting a transition delay for actors\n       */\n      [A.setTransitionDelay]: assign({\n        actorTransitionDelay: (ctx, event) => {\n          if (event.type === E.changeTransitionDelayReq) {\n            return event.delay;\n          }\n\n          return ctx.actorTransitionDelay;\n        },\n      }),\n\n      /**\n       * Sending a message to an agent or waiting for a user to move\n       */\n      [A.awaitTurn]: (ctx) => {\n        const player = ctx.opponents[ctx.turnOrder.current];\n        if (player.type === PLAYER_TYPE.agent) {\n          player.ref.send({\n            type: Msg.makeTurnReq,\n            field: ctx.field,\n            player: ctx.turnOrder.current,\n            transitionDelay: ctx.actorTransitionDelay,\n          });\n        } else {\n          // just waiting for a user to make their move\n        }\n      },\n\n      /**\n       * Saving current turn to context\n       */\n      [A.saveTurn]: assign({\n        field: (ctx, event) => {\n          if (event.type === E.acceptTurnReq) {\n            const newField: FieldContext = [...ctx.field];\n            const newSymbol = ctx.opponents[event.sender].symbol;\n            newField[event.index] = newSymbol;\n            return newField;\n          }\n\n          return ctx.field;\n        },\n      }),\n\n      /**\n       * Saving surrender signal when player throws a game\n       */\n      [A.saveSurrender]: assign({\n        surrendered: (ctx) => {\n          return ctx.turnOrder.current;\n        },\n      }),\n\n      [A.tryGameEnd]: assign({\n        winCombo: ({ field, winCombo }) => {\n          const someCombo = FIELD.combinations.find((combination) => {\n            const [a, b, c] = combination;\n            if (field[a] && field[a] === field[b] && field[a] === field[c]) {\n              return true;\n            }\n            return false;\n          });\n\n          const hasFreeSpace = field.some((cellValue) => cellValue === null);\n          if (someCombo || !hasFreeSpace) {\n            return someCombo as TicTacToeContext['winCombo'];\n          }\n          return winCombo;\n        },\n      }),\n\n      /**\n       * Switch to other player\n       */\n      [A.switchTurn]: assign({\n        turnOrder: (ctx) => ({\n          ...ctx.turnOrder,\n          current: ctx.turnOrder.current === PLAYER_NUM.player1 ? PLAYER_NUM.player2 : PLAYER_NUM.player1,\n          turnsMade: ctx.turnOrder.turnsMade + 1,\n        }),\n      }),\n    },\n  },\n);\n","import styled from '@emotion/styled';\n\nexport const MenuButton = styled.button`\n  min-width: 150px;\n  height: 50px;\n  cursor: pointer;\n`;\n","import styled from '@emotion/styled';\nimport { MenuButton } from '../../components/MenuButton';\n\nimport {\n  PLAYER_NUM,\n  PLAYER_TYPE,\n  TTT_EVENT_TYPE as E,\n  TicTacToeTransitionDelay,\n  TTT_DELAY_OPTIONS,\n  TicTacToeMachineSend,\n} from '../../features/TicTacToe';\n\nconst MenuContainer = styled.div`\n  display: grid;\n  gap: 8px;\n`;\n\nconst TransitionDelaySelect = styled.select`\n  cursor: pointer;\n`;\n\nconst RENDER_DELAY_OPTIONS = Object.values(TTT_DELAY_OPTIONS)\n  .sort((a, b) => (a > b ? 1 : -1))\n  .map((delay) => (\n    <option key={delay} value={delay}>\n      {delay}ms\n    </option>\n  ));\n\ntype TicTacToePageSettingUpProps = {\n  send: TicTacToeMachineSend;\n};\n\n/**\n * Represents first phase of the game, by showing starting options and configuration.\n */\nexport const TicTacToePageSettingUp: React.FC<TicTacToePageSettingUpProps> = ({ send }) => {\n  // the ttt machine configured to play pvp by default\n  // , so we only need to send continueReq\n  const startPvPGame = () => send({ type: E.continueReq });\n\n  // to set a PvA game, we need to send changePlayerReq to set second player to be agent\n  // , and continueReq to start playing\n  const startPvAGame = () => {\n    send({\n      type: E.changePlayerReq,\n      kind: PLAYER_NUM.player2,\n      value: PLAYER_TYPE.agent,\n    });\n    send({ type: E.continueReq });\n  };\n\n  // to set a AvA, we need to set both players to be agents\n  // , and then send continueReq\n  const startAvAGame = () => {\n    send({\n      type: E.changePlayerReq,\n      kind: PLAYER_NUM.player1,\n      value: PLAYER_TYPE.agent,\n    });\n    send({\n      type: E.changePlayerReq,\n      kind: PLAYER_NUM.player2,\n      value: PLAYER_TYPE.agent,\n    });\n    send({ type: E.continueReq });\n  };\n\n  // to update transition delay we should not forget to cast target.value to Number\n  const updateDelay = (e: React.ChangeEvent<HTMLSelectElement>) => {\n    send({\n      type: E.changeTransitionDelayReq,\n      delay: Number(e.target.value) as TicTacToeTransitionDelay,\n    });\n  };\n\n  return (\n    <MenuContainer>\n      <MenuButton type=\"button\" onClick={startPvPGame}>\n        Player vs Player\n      </MenuButton>\n      <MenuButton type=\"button\" onClick={startPvAGame}>\n        Player vs AI\n      </MenuButton>\n      <MenuButton type=\"button\" onClick={startAvAGame}>\n        AI vs AI\n      </MenuButton>\n      <span>\n        delay transitions <br /> to see them in inspector frame:\n      </span>\n      <TransitionDelaySelect defaultValue={TTT_DELAY_OPTIONS.default} onChange={updateDelay}>\n        {RENDER_DELAY_OPTIONS}\n      </TransitionDelaySelect>\n      <span>\n        switch from machine(x:n) <br /> to a player in inspector frame <br /> when game starts\n      </span>\n    </MenuContainer>\n  );\n};\n","// placeholder to block unwanted actions\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop: () => void = () => {};\n","import styled from '@emotion/styled';\nimport React from 'react';\nimport { noop } from '../common/noop';\nimport { FIELD, FieldCellIndex, FieldCellValue, FieldContext } from '../features/TicTacToe';\n\nconst FieldGrid = styled.div`\n  display: grid;\n  grid-template-columns: 100px 100px 100px;\n  grid-template-rows: 100px 100px 100px;\n  gap: 8px;\n`;\n\ntype FieldCellProps = Pick<TicTacToeFieldProps, 'isFirstTurn' | 'isPlayersTurn' | 'winCombo'> & {\n  cellIndex: FieldCellIndex;\n  cellValue: FieldCellValue;\n};\n\nconst FieldCell = styled.div<FieldCellProps>`\n  outline: 1px solid gray;\n  cursor: pointer;\n  font-size: 50px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background-color: ${({ isFirstTurn, isPlayersTurn, winCombo, cellValue, cellIndex }) => {\n    // if we have `winCombo`, then game has ended\n    if (winCombo) {\n      return winCombo.includes(cellIndex) ? 'green' : undefined;\n    }\n\n    // if game continues and cell is free\n    const isPlayerAndFirstTurnCenterIsFree = isPlayersTurn && cellIndex === FIELD.center && cellValue === null;\n    const isPlayerAndTheCellIsFree = isPlayersTurn && !isFirstTurn && cellValue === null;\n    if (isPlayerAndFirstTurnCenterIsFree || isPlayerAndTheCellIsFree) {\n      return '#cbffb6';\n    }\n\n    // nothing to highlight regardless of game-state\n    return undefined;\n  }};\n  transition: background 0.5s ease;\n`;\n\ntype TicTacToeFieldProps = {\n  field: FieldContext;\n  // eslint-disable-next-line no-unused-vars\n  onCellClick?: (index: FieldCellIndex) => () => void;\n  isFirstTurn?: boolean;\n  isPlayersTurn?: boolean;\n  winCombo?: [FieldCellIndex, FieldCellIndex, FieldCellIndex] | null;\n};\n\n/**\n * TicTacToe basic game-field\n */\nexport const TicTacToeField: React.FC<TicTacToeFieldProps> = React.memo(\n  ({ field, onCellClick, isFirstTurn, isPlayersTurn, winCombo }) => {\n    return (\n      <FieldGrid>\n        {field.map((cellValue, index) => {\n          const cellIndex = index as FieldCellIndex;\n          return (\n            <FieldCell\n              // this time it's gonna be alright, don`t worry :)\n              // eslint-disable-next-line react/no-array-index-key\n              key={cellIndex}\n              role=\"button\"\n              tabIndex={cellIndex}\n              onKeyDown={noop}\n              isFirstTurn={isFirstTurn}\n              isPlayersTurn={isPlayersTurn}\n              winCombo={winCombo}\n              cellIndex={cellIndex}\n              cellValue={cellValue}\n              onClick={onCellClick?.(cellIndex)}\n            >\n              {cellValue}\n            </FieldCell>\n          );\n        })}\n      </FieldGrid>\n    );\n  },\n);\n","import styled from '@emotion/styled';\n\nexport const GameContainer = styled.div`\n  display: grid;\n  gap: 16px;\n`;\n\nexport const TurnStateComment = styled.h3``;\n","import React from 'react';\nimport { noop } from '../../common/noop';\nimport { MenuButton } from '../../components/MenuButton';\nimport { TicTacToeField } from '../../components/TicTacToeField';\nimport {\n  TicTacToeMachineSend,\n  PLAYER_TYPE,\n  FieldCellIndex,\n  TicTacToeMachineState,\n  TTT_EVENT_TYPE as E,\n} from '../../features/TicTacToe';\nimport { GameContainer, TurnStateComment } from './common';\n\ntype TicTacToePagePlayingProps = {\n  send: TicTacToeMachineSend;\n  machineState: TicTacToeMachineState;\n};\n\n/**\n * Represents `playing` part of the game, by showing the field, x|0 symbols, highlighting steps and turns.\n */\nexport const TicTacToePagePlaying: React.FC<TicTacToePagePlayingProps> = ({ send, machineState }) => {\n  const currentPlayer = machineState.context.turnOrder.current;\n  const { symbol: currentPlayerSymbol } = machineState.context.opponents[currentPlayer];\n  const isPlayersTurn = machineState.context.opponents[currentPlayer].type === PLAYER_TYPE.user;\n  const isFirstTurn = machineState.context.turnOrder.turnsMade === 0;\n\n  const makeTurn = React.useMemo(() => {\n    return isPlayersTurn\n      ? (index: FieldCellIndex) => () => {\n          send({\n            type: E.acceptTurnReq,\n            index,\n            sender: currentPlayer,\n          });\n        }\n      : () => noop;\n  }, [isPlayersTurn]);\n\n  return (\n    <GameContainer>\n      <TurnStateComment>{`${currentPlayer} (${currentPlayerSymbol}) to make turn`}</TurnStateComment>\n      <TicTacToeField\n        field={machineState.context.field}\n        onCellClick={makeTurn}\n        isFirstTurn={isFirstTurn}\n        isPlayersTurn={isPlayersTurn}\n      />\n      {isPlayersTurn ? (\n        <MenuButton type=\"button\" onClick={() => send({ type: E.giveUpReq })}>\n          Give up\n        </MenuButton>\n      ) : (\n        <MenuButton type=\"button\" disabled>\n          ---\n        </MenuButton>\n      )}\n    </GameContainer>\n  );\n};\n","import styled from '@emotion/styled';\nimport React from 'react';\nimport { MenuButton } from '../../components/MenuButton';\nimport { TicTacToeField } from '../../components/TicTacToeField';\nimport { TTT_EVENT_TYPE as E, TicTacToeMachineSend, TicTacToeMachineState } from '../../features/TicTacToe';\nimport { GameContainer, TurnStateComment } from './common';\n\nconst EndResultComment = styled.div``;\n\ntype TicTacToePageEndResultsProps = {\n  send: TicTacToeMachineSend;\n  machineState: TicTacToeMachineState;\n};\n\nexport const TicTacToePageEndResults: React.FC<TicTacToePageEndResultsProps> = ({ send, machineState }) => {\n  const { winCombo, surrendered } = machineState.context;\n\n  return (\n    <GameContainer>\n      <TurnStateComment>Game ended</TurnStateComment>\n      <TicTacToeField field={machineState.context.field} winCombo={machineState.context.winCombo} />\n      <MenuButton type=\"button\" onClick={() => send({ type: E.retryReq })}>\n        Retry\n      </MenuButton>\n      <MenuButton type=\"button\" onClick={() => send({ type: E.setUpNewGame })}>\n        New game\n      </MenuButton>\n\n      {winCombo && <EndResultComment>{`Win combination ${winCombo}`}</EndResultComment>}\n      {surrendered && <EndResultComment>{`${surrendered} surrendered!`}</EndResultComment>}\n      {!winCombo && !surrendered && <EndResultComment>It`s a draw</EndResultComment>}\n    </GameContainer>\n  );\n};\n","import { useMachine } from '@xstate/react';\nimport { useEffect } from 'react';\nimport { inspect } from '@xstate/inspect';\nimport styled from '@emotion/styled';\nimport { TicTacToeMachine, TTT_STATE as S } from '../../features/TicTacToe';\nimport { TicTacToePageSettingUp } from './TicTacToePage.settingUp';\nimport { TicTacToePagePlaying } from './TicTacToePage.playing';\nimport { TicTacToePageEndResults } from './TicTacToePage.endResults';\n\ninspect({ iframe: () => document.getElementById('stately-frame') as HTMLIFrameElement });\n\nconst TicTacToePageContainer = styled.div`\n  margin: 10% auto auto auto;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n`;\n\nexport const TicTacToePage: React.FC = () => {\n  const [machineState, send] = useMachine(TicTacToeMachine, { devTools: true });\n  const renderMachineState = () => {\n    switch (true) {\n      case machineState.matches(S.settingUp): {\n        return <TicTacToePageSettingUp send={send} />;\n      }\n\n      case machineState.matches(S.playing): {\n        return <TicTacToePagePlaying send={send} machineState={machineState} />;\n      }\n\n      case machineState.matches(S.showingGameEndResults): {\n        return <TicTacToePageEndResults send={send} machineState={machineState} />;\n      }\n\n      default:\n        return <div>UNKNOWN STATE</div>;\n    }\n  };\n\n  useEffect(() => {\n    // so you could also sneak into console to check what's going on\n    // eslint-disable-next-line no-console\n    console.log({\n      turn: machineState.context.turnOrder.turnsMade,\n      context: machineState.context,\n      events: machineState.events,\n      value: machineState.value,\n    });\n  });\n\n  return <TicTacToePageContainer>{renderMachineState()}</TicTacToePageContainer>;\n};\n","import { TicTacToePage } from '../pages/TicTacToePage';\n\nexport const App: React.FC = () => {\n  return <TicTacToePage />;\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\n\nimport { App } from './app-container';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
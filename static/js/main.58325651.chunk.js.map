{"version":3,"sources":["reportWebVitals.ts","features/TicTacToe.common.ts","features/TicTacToe.actor.types.ts","features/TicTacToe.actor.business.ts","features/TicTacToe.actor.ts","features/TicTacToe.machine.types.ts","features/TicTacToe.machine.ts","pages/TicTacToePage.tsx","app-container/App.tsx","index.tsx"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","PLAYER_TYPE","PLAYER_NUM","PLAYER_SYMBOL","ROWS","COLUMNS","DIAGONALS","FIELD","CORNERS","TOP_LEFT","TOP_RIGHT","BOT_LEFT","BOT_RIGHT","EDGES","TOP","LEFT","RIGHT","BOT","CENTER","COMBINATIONS","FIELD_INITIAL","TicTacToeEventTypes","TIC_TAC_TOE_DELAY_OPTIONS","0","default","500","700","1000","TicTacToeActorEventTypes","TicTacToeActorStateNodes","TicTacToeActorConditions","TicTacToeActorActions","getOpponent","symbol","MAKING_TURN_ACTION","target","S","cond","C","delay","ctx","transitionDelay","createTicTacToeActor","givenSymbol","createMachine","context","field","player","moveReady","initial","states","on","E","actions","A","after","entry","guards","type","assign","_","event","sendParent","Msg","index","turnTo","sender","tryWinning","tryForking","opponent","possibleOppositeCorners","is","filter","inv","oppositeCorner","sample","possibleFreeCorners","value","corner","freeCorner","possibleFreeSides","side","freeSide","combination","find","row","reduce","acc","find2InARowWith1Free","undefined","fork","oneTakenAnd2Blanks","line","rows","columns","diagonals","length","intersection","intersectionEmpty","intersectionIndex","column","findAFork","TicTacToeStateNodes","TicTacToeMachineActions","TicTacToeMachineConditions","initialContext","actorTransitionDelay","opponents","turnOrder","current","turnsMade","winCombo","surrendered","TicTacToeMachine","always","id","Boolean","currentPlayerInfo","kind","ref","stop","newPlayerSymbol","newPlayerInfo","spawn","name","first","send","newField","newSymbol","someCombo","a","b","c","hasFreeSpace","some","cellValue","inspect","iframe","document","getElementById","noop","TicTacToePage","useMachine","devTools","machineState","useEffect","console","log","turn","events","style","width","margin","display","flexDirection","justifyContent","alignItems","matches","gap","minWidth","height","onClick","defaultValue","onChange","e","Number","Object","values","map","currentPlayer","currentPlayerSymbol","isPlayersTurn","isFirstTurn","makeTurn","gridTemplateColumns","gridTemplateRows","cell","outline","cursor","fontSize","backgroundColor","transition","role","tabIndex","onKeyDown","disabled","title","background","includes","renderMachineState","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.58325651.chunk.js","sourcesContent":["// eslint-disable-next-line\n// @ts-ignore\nimport { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { ActorRef } from 'xstate';\n\nexport const PLAYER_TYPE = {\n  user: 'user',\n  agent: 'agent',\n} as const;\n\nexport type PlayerContext =\n  | { type: typeof PLAYER_TYPE.user }\n  | {\n      type: typeof PLAYER_TYPE.agent;\n      ref: ActorRef<TicTacToeActorEvents>;\n    };\n\nexport const PLAYER_NUM = {\n  player1: 'player1',\n  player2: 'player2',\n} as const;\n\nexport type PlayerTurnContext = typeof PLAYER_NUM[keyof typeof PLAYER_NUM];\n\nexport const PLAYER_SYMBOL = {\n  x: 'x',\n  o: '0',\n} as const;\n\nexport type PlayerFieldSymbol = typeof PLAYER_SYMBOL[keyof typeof PLAYER_SYMBOL];\n\ntype FieldCellValue = PlayerFieldSymbol | null;\nexport type FieldCellIndex = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n\n// strictly 9 cells\nexport type FieldContext = [\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n];\n\nexport const ROWS: FieldCellIndex[][] = [\n  [0, 1, 2],\n  [3, 4, 5],\n  [6, 7, 8],\n];\n\nexport const COLUMNS: FieldCellIndex[][] = [\n  [0, 3, 6],\n  [1, 4, 7],\n  [2, 5, 8],\n];\n\nexport const DIAGONALS: FieldCellIndex[][] = [\n  [0, 4, 8],\n  [2, 4, 6],\n];\n\nexport const FIELD = {\n  CORNERS: {\n    TOP_LEFT: 0 as FieldCellIndex,\n    TOP_RIGHT: 2 as FieldCellIndex,\n    BOT_LEFT: 6 as FieldCellIndex,\n    BOT_RIGHT: 8 as FieldCellIndex,\n  },\n  EDGES: {\n    TOP: 1 as FieldCellIndex,\n    LEFT: 3 as FieldCellIndex,\n    RIGHT: 5 as FieldCellIndex,\n    BOT: 7 as FieldCellIndex,\n  },\n  CENTER: 4 as FieldCellIndex,\n  COMBINATIONS: [...ROWS, ...COLUMNS, ...DIAGONALS],\n  ROWS,\n  COLUMNS,\n  DIAGONALS,\n};\n\nexport const FIELD_INITIAL: FieldContext = [null, null, null, null, null, null, null, null, null];\n\nexport const TicTacToeEventTypes = {\n  CHANGE_PLAYER_REQ: 'CHANGE_PLAYER_REQ',\n  CONTINUE_REQ: 'CONTINUE_REQ',\n  CHANGE_TURN_ORDER_REQ: 'CHANGE_TURN_ORDER_REQ',\n  CHANGE_TRANSITION_DELAY_REQ: 'CHANGE_TRANSITION_DELAY_REQ',\n  ACCEPT_TURN_REQ: 'ACCEPT_TURN_REQ',\n  GIVE_UP_TURN_REQ: 'GIVE_UP_TURN_REQ',\n  RETRY_REQ: 'RETRY_REQ',\n  SET_UP_NEW_GAME: 'SET_UP_NEW_GAME',\n} as const;\n\nexport type TicTacToeEvents =\n  | { type: typeof TicTacToeEventTypes.CHANGE_PLAYER_REQ; kind: PlayerTurnContext; value: PlayerContext['type'] }\n  | { type: typeof TicTacToeEventTypes.CONTINUE_REQ }\n  | { type: typeof TicTacToeEventTypes.CHANGE_TURN_ORDER_REQ; first: PlayerTurnContext }\n  | { type: typeof TicTacToeEventTypes.CHANGE_TRANSITION_DELAY_REQ; delay: TicTacToeTransitionDelay }\n  | { type: typeof TicTacToeEventTypes.ACCEPT_TURN_REQ; index: FieldCellIndex; sender: PlayerTurnContext }\n  | { type: typeof TicTacToeEventTypes.GIVE_UP_TURN_REQ }\n  | { type: typeof TicTacToeEventTypes.RETRY_REQ }\n  | { type: typeof TicTacToeEventTypes.SET_UP_NEW_GAME };\n\nexport const TIC_TAC_TOE_DELAY_OPTIONS = {\n  0: 0,\n  default: 300,\n  500: 500,\n  700: 700,\n  1000: 1000,\n} as const;\n\nexport type TicTacToeTransitionDelay = typeof TIC_TAC_TOE_DELAY_OPTIONS[keyof typeof TIC_TAC_TOE_DELAY_OPTIONS];\n\nexport type TicTacToeContext = {\n  actorTransitionDelay: TicTacToeTransitionDelay;\n\n  opponents: {\n    [PLAYER_NUM.player1]: PlayerContext & { symbol: Extract<PlayerFieldSymbol, typeof PLAYER_SYMBOL.x> };\n    [PLAYER_NUM.player2]: PlayerContext & { symbol: Extract<PlayerFieldSymbol, typeof PLAYER_SYMBOL.o> };\n  };\n\n  turnOrder: {\n    current: PlayerTurnContext;\n    turnsMade: number;\n  };\n\n  field: FieldContext;\n\n  winCombo: [FieldCellIndex, FieldCellIndex, FieldCellIndex] | null;\n  surrendered: PlayerTurnContext | null;\n};\n\nexport const TicTacToeActorEventTypes = {\n  MAKE_TURN_REQ: 'MAKE_TURN_REQ',\n} as const;\n\n// Machine to Actor -- Msg\nexport type TicTacToeActorEvents = {\n  type: typeof TicTacToeActorEventTypes.MAKE_TURN_REQ;\n  field: FieldContext;\n  player: PlayerTurnContext;\n  transitionDelay: TicTacToeTransitionDelay;\n};\n","import {\n  PlayerFieldSymbol,\n  FieldCellIndex,\n  TicTacToeContext,\n  PlayerTurnContext,\n  TicTacToeTransitionDelay,\n} from './TicTacToe.common';\n\nexport type TicTacToeActorContext = {\n  field: TicTacToeContext['field'];\n  player: PlayerTurnContext;\n  symbol: PlayerFieldSymbol;\n  moveReady: { type: 'commit'; turnTo: FieldCellIndex } | { type: 'tryOtherMove' } | null;\n  transitionDelay: TicTacToeTransitionDelay;\n};\n\nexport const TicTacToeActorStateNodes = {\n  awaitingTurn: '@/awaitingTurn',\n  makingTurn: '@/makingTurn',\n  tryingToWin: '@/tryingToWin',\n  tryingToBlockWin: '@/tryingToBlockWin',\n  tryingToFork: '@/tryingToFork',\n  tryingToBlockFork: '@/tryingToBlockFork',\n  tryingToTakeCenter: '@/tryingToTakeCenter',\n  tryingToTakeOppositeCorner: '@/tryingToTakeOppositeCorner',\n  tryingToTakeCorner: '@/tryingToTakeCorner',\n  tryingToTakeEmptySide: '@/tryingToTakeEmptySide',\n  givingUp: '@/givingUp',\n} as const;\n\nexport type TicTacToeActorState = {\n  context: TicTacToeActorContext;\n  value:\n    | typeof TicTacToeActorStateNodes.awaitingTurn\n    | typeof TicTacToeActorStateNodes.makingTurn\n    | typeof TicTacToeActorStateNodes.tryingToWin\n    | typeof TicTacToeActorStateNodes.tryingToBlockWin\n    | typeof TicTacToeActorStateNodes.tryingToFork\n    | typeof TicTacToeActorStateNodes.tryingToBlockFork\n    | typeof TicTacToeActorStateNodes.tryingToTakeCenter\n    | typeof TicTacToeActorStateNodes.tryingToTakeOppositeCorner\n    | typeof TicTacToeActorStateNodes.tryingToTakeCorner\n    | typeof TicTacToeActorStateNodes.tryingToTakeEmptySide\n    | typeof TicTacToeActorStateNodes.givingUp;\n};\n\nexport const TicTacToeActorConditions = {\n  verifyTurnReady: 'verifyTurnReady',\n} as const;\n\nexport const TicTacToeActorActions = {\n  saveField: 'saveField',\n  makeTurn: 'makeTurn',\n  tryWinning: 'tryWinning',\n  tryBlockingWin: 'tryBlockingWin',\n  tryForking: 'tryForking',\n  tryBlockingFork: 'tryBlockingFork',\n  tryTakingCenter: 'tryTakingCenter',\n  tryTakingOppositeCorner: 'tryTakingOppositeCorner',\n  tryTakingCorner: 'tryTakingCorner',\n  tryTakingSide: 'tryTakingSide',\n  giveUp: 'giveUp',\n} as const;\n","import {\n  PlayerFieldSymbol,\n  PLAYER_SYMBOL,\n  FieldContext,\n  FIELD,\n  FieldCellIndex,\n  ROWS,\n  COLUMNS,\n  DIAGONALS,\n} from './TicTacToe.common';\n\nexport function getOpponent(symbol: PlayerFieldSymbol): PlayerFieldSymbol {\n  return symbol === PLAYER_SYMBOL.x ? PLAYER_SYMBOL.o : PLAYER_SYMBOL.x;\n}\n\nexport function find2InARowWith1Free(field: FieldContext, symbol: PlayerFieldSymbol): FieldCellIndex[] | undefined {\n  const opponent = getOpponent(symbol);\n  const twoInARow = FIELD.COMBINATIONS.find((row) => {\n    const actorSymbolsInARow = row.reduce<number>((acc, index) => {\n      if (field[index] === symbol) {\n        return acc + 1;\n      }\n\n      if (field[index] === opponent) {\n        return acc - 1;\n      }\n\n      return acc;\n    }, 0);\n\n    return actorSymbolsInARow === 2;\n  });\n\n  return twoInARow;\n}\n\nexport function findAFork(\n  field: FieldContext,\n  symbol: PlayerFieldSymbol,\n): { intersectionIndex: FieldCellIndex } | null {\n  // if there are two intersecting rows, columns, or diagonals\n  // with one of my pieces and two blanks,\n  // =====================================\n  //  [*,X,*]\n  //  [X,_,_] <- 2 blanks on row 2\n  //  [*,_,*]\n  //     ^- 2 blanks on col 2\n  //  cell 4 (center) is an intersection\n  // =====================================\n  // and if the intersecting space is empty\n  const oneTakenAnd2Blanks = (line: FieldCellIndex[]) => {\n    const howManyTaken = line.reduce<number>((acc, index) => {\n      if (field[index] === symbol) {\n        return acc + 1;\n      }\n\n      if (field[index] === null) {\n        return acc;\n      }\n\n      return acc - 1;\n    }, 0);\n\n    return howManyTaken === 1;\n  };\n\n  const rows = ROWS.filter(oneTakenAnd2Blanks);\n  const columns = COLUMNS.filter(oneTakenAnd2Blanks);\n  const diagonals = DIAGONALS.filter(oneTakenAnd2Blanks);\n\n  // scanning rows-first\n  if (rows.length) {\n    for (const row of rows) {\n      for (const index of row) {\n        // against columns\n        for (const column of columns) {\n          const intersection = index in column;\n          const intersectionEmpty = field[index] === null;\n          if (intersection && intersectionEmpty) {\n            return {\n              intersectionIndex: index,\n            };\n          }\n        }\n\n        // against diagonals\n        for (const diag of diagonals) {\n          const intersection = index in diag;\n          const intersectionEmpty = field[index] === null;\n          if (intersection && intersectionEmpty) {\n            return {\n              intersectionIndex: index,\n            };\n          }\n        }\n      }\n    }\n  }\n\n  // scanning columns-first\n  if (columns.length) {\n    for (const column of columns) {\n      for (const index of column) {\n        // against diagonals\n        // (already scanned against rows if they were available)\n        for (const diag of diagonals) {\n          const intersection = index in diag;\n          const intersectionEmpty = field[index] === null;\n          if (intersection && intersectionEmpty) {\n            return {\n              intersectionIndex: index,\n            };\n          }\n        }\n      }\n    }\n  }\n\n  // 2 diagonals can only intersect in the center\n  if (diagonals.length === 2 && field[FIELD.CENTER] === null) {\n    return { intersectionIndex: FIELD.CENTER };\n  }\n\n  return null;\n}\n","import { createMachine, StateMachine, assign, sendParent, Expr } from 'xstate';\n\nimport sample from 'lodash.sample';\n\nimport {\n  TicTacToeActorEvents,\n  TicTacToeActorEventTypes as E,\n  TicTacToeEventTypes as Msg,\n  TicTacToeEvents,\n  FIELD_INITIAL,\n  PlayerFieldSymbol,\n  TicTacToeEventTypes,\n  FIELD,\n  FieldContext,\n  PLAYER_NUM,\n  TIC_TAC_TOE_DELAY_OPTIONS,\n} from './TicTacToe.common';\nimport {\n  TicTacToeActorContext,\n  TicTacToeActorState,\n  TicTacToeActorActions as A,\n  TicTacToeActorConditions as C,\n  TicTacToeActorStateNodes as S,\n} from './TicTacToe.actor.types';\nimport { getOpponent, find2InARowWith1Free, findAFork } from './TicTacToe.actor.business';\n\nconst MSG_DELAY = 300;\n\nconst MAKING_TURN_ACTION = {\n  target: S.makingTurn,\n  cond: C.verifyTurnReady,\n  delay: ((ctx) => ctx.transitionDelay) as Expr<TicTacToeActorContext, TicTacToeActorEvents, number>,\n} as const;\n\n/**\n * This machine defines actor' states using\n * Newell and Simon's expert model with rule ordering:\n *\n * - https://en.wikipedia.org/wiki/Tic-tac-toe#Combinatorics\n * - https://en.wikipedia.org/wiki/Tic-tac-toe#Strategy\n * - https://doi.org/10.1016%2F0364-0213%2893%2990003-Q\n */\nexport const createTicTacToeActor = (\n  givenSymbol: PlayerFieldSymbol,\n): StateMachine<TicTacToeActorContext, Record<string, unknown>, TicTacToeActorEvents, TicTacToeActorState> =>\n  createMachine<TicTacToeActorContext, TicTacToeActorEvents, TicTacToeActorState>(\n    {\n      context: {\n        field: FIELD_INITIAL,\n        player: PLAYER_NUM.player2,\n        symbol: givenSymbol,\n        moveReady: null,\n        transitionDelay: TIC_TAC_TOE_DELAY_OPTIONS.default,\n      },\n      initial: S.awaitingTurn,\n      states: {\n        [S.awaitingTurn]: {\n          on: {\n            [E.MAKE_TURN_REQ]: {\n              target: S.tryingToWin,\n              actions: [A.saveField],\n            },\n          },\n        },\n\n        [S.makingTurn]: {\n          /**\n           * NOTE: I'm only adding transition delay for educational purposes\n           *       so we could clearly see in inspector what's happening with the actor.\n           *\n           * Otherwise, I'd be using `always` instead of `after`.\n           */\n          after: [\n            {\n              target: S.awaitingTurn,\n              actions: A.makeTurn,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n\n        [S.tryingToWin]: {\n          entry: A.tryWinning,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToBlockWin,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToBlockWin]: {\n          entry: A.tryBlockingWin,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToFork,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToFork]: {\n          entry: A.tryForking,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToBlockFork,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToBlockFork]: {\n          entry: A.tryBlockingFork,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToTakeCenter,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToTakeCenter]: {\n          entry: A.tryTakingCenter,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToTakeOppositeCorner,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToTakeOppositeCorner]: {\n          entry: A.tryTakingOppositeCorner,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToTakeCorner,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToTakeCorner]: {\n          entry: A.tryTakingCorner,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToTakeEmptySide,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n        [S.tryingToTakeEmptySide]: {\n          entry: A.tryTakingSide,\n          after: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.givingUp,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n\n        [S.givingUp]: {\n          after: [\n            {\n              target: S.awaitingTurn,\n              actions: A.giveUp,\n              delay: (ctx) => ctx.transitionDelay,\n            },\n          ],\n        },\n      },\n    },\n    {\n      guards: {\n        [C.verifyTurnReady]: ({ moveReady }: TicTacToeActorContext) => moveReady?.type === 'commit',\n      },\n      actions: {\n        /**\n         * CHILD-PARENT Msg ===================================================\n         */\n\n        [A.saveField]: assign({\n          player: (_, event) => event.player,\n          field: (_, event) => event.field,\n          transitionDelay: (_, event) => event.transitionDelay,\n        }),\n\n        [A.makeTurn]: sendParent(\n          ({\n            player,\n            moveReady,\n          }): Extract<\n            TicTacToeEvents,\n            { type: typeof TicTacToeEventTypes.ACCEPT_TURN_REQ | typeof TicTacToeEventTypes.GIVE_UP_TURN_REQ }\n          > => {\n            if (moveReady?.type === 'commit') {\n              return { type: Msg.ACCEPT_TURN_REQ, index: moveReady.turnTo, sender: player };\n            }\n\n            return { type: Msg.GIVE_UP_TURN_REQ };\n          },\n          { delay: MSG_DELAY },\n        ),\n\n        [A.giveUp]: sendParent(\n          (): Extract<TicTacToeEvents, { type: typeof TicTacToeEventTypes.GIVE_UP_TURN_REQ }> => {\n            return { type: Msg.GIVE_UP_TURN_REQ };\n          },\n          { delay: MSG_DELAY },\n        ),\n\n        /**\n         * ACTOR BUSINESS =====================================================\n         */\n\n        [A.tryWinning]: assign({\n          moveReady: ({ field, symbol }) => {\n            return tryWinning(field, symbol);\n          },\n        }),\n        [A.tryBlockingWin]: assign({\n          moveReady: ({ field, symbol }) => {\n            const opponentSymbol = getOpponent(symbol);\n            return tryWinning(field, opponentSymbol);\n          },\n        }),\n        [A.tryForking]: assign({\n          moveReady: ({ field, symbol }) => {\n            return tryForking(field, symbol);\n          },\n        }),\n        [A.tryBlockingFork]: assign({\n          moveReady: ({ field, symbol }) => {\n            const opponentSymbol = getOpponent(symbol);\n            return tryForking(field, opponentSymbol);\n          },\n        }),\n        [A.tryTakingCenter]: assign({\n          moveReady: ({ field }) => {\n            if (field[FIELD.CENTER] === null) {\n              return { type: 'commit', turnTo: FIELD.CENTER };\n            }\n\n            return { type: 'tryOtherMove' };\n          },\n        }),\n        [A.tryTakingOppositeCorner]: assign({\n          moveReady: ({ field, symbol }) => {\n            const opponent = getOpponent(symbol);\n            // if my opponent is in a corner, and\n            // if the opposite corner is empty\n            const corners = [\n              {\n                is: field[FIELD.CORNERS.TOP_LEFT] === opponent && field[FIELD.CORNERS.BOT_RIGHT] === null,\n                index: FIELD.CORNERS.BOT_RIGHT,\n              },\n              {\n                is: field[FIELD.CORNERS.TOP_RIGHT] === opponent && field[FIELD.CORNERS.BOT_LEFT] === null,\n                index: FIELD.CORNERS.BOT_LEFT,\n              },\n              {\n                is: field[FIELD.CORNERS.BOT_LEFT] === opponent && field[FIELD.CORNERS.TOP_RIGHT] === null,\n                index: FIELD.CORNERS.TOP_RIGHT,\n              },\n              {\n                is: field[FIELD.CORNERS.BOT_RIGHT] === opponent && field[FIELD.CORNERS.TOP_LEFT] === null,\n                index: FIELD.CORNERS.TOP_LEFT,\n              },\n            ];\n\n            const possibleOppositeCorners = corners.filter((inv) => inv.is);\n            const oppositeCorner = sample(possibleOppositeCorners);\n            if (oppositeCorner) {\n              return { type: 'commit', turnTo: oppositeCorner.index };\n            }\n\n            return { type: 'tryOtherMove' };\n          },\n        }),\n        [A.tryTakingCorner]: assign({\n          moveReady: ({ field }) => {\n            const corners = [\n              { value: field[FIELD.CORNERS.TOP_LEFT], index: FIELD.CORNERS.TOP_LEFT },\n              { value: field[FIELD.CORNERS.TOP_RIGHT], index: FIELD.CORNERS.TOP_RIGHT },\n              { value: field[FIELD.CORNERS.BOT_LEFT], index: FIELD.CORNERS.BOT_LEFT },\n              { value: field[FIELD.CORNERS.BOT_RIGHT], index: FIELD.CORNERS.BOT_RIGHT },\n            ];\n\n            const possibleFreeCorners = corners.filter((corner) => corner.value === null);\n            const freeCorner = sample(possibleFreeCorners);\n            if (freeCorner) {\n              return { type: 'commit', turnTo: freeCorner.index };\n            }\n\n            return { type: 'tryOtherMove' };\n          },\n        }),\n        [A.tryTakingSide]: assign({\n          moveReady: ({ field }) => {\n            const sides = [\n              { value: field[FIELD.EDGES.TOP], index: FIELD.EDGES.TOP },\n              { value: field[FIELD.EDGES.LEFT], index: FIELD.EDGES.LEFT },\n              { value: field[FIELD.EDGES.RIGHT], index: FIELD.EDGES.RIGHT },\n              { value: field[FIELD.EDGES.BOT], index: FIELD.EDGES.BOT },\n            ];\n\n            const possibleFreeSides = sides.filter((side) => side.value === null);\n            const freeSide = sample(possibleFreeSides);\n            if (freeSide) {\n              return { type: 'commit', turnTo: freeSide.index };\n            }\n\n            return { type: 'tryOtherMove' };\n          },\n        }),\n      },\n    },\n  );\n\n/*\n * COMMON ACTIONS =============================================================\n */\n\nfunction tryWinning(field: FieldContext, symbol: PlayerFieldSymbol): TicTacToeActorContext['moveReady'] {\n  const combination = find2InARowWith1Free(field, symbol);\n  const turnTo = combination?.find((index) => field[index] === null);\n  if (turnTo !== undefined) {\n    return { type: 'commit', turnTo };\n  }\n\n  return { type: 'tryOtherMove' };\n}\n\nfunction tryForking(field: FieldContext, symbol: PlayerFieldSymbol): TicTacToeActorContext['moveReady'] {\n  const fork = findAFork(field, symbol);\n  if (fork) {\n    return { type: 'commit', turnTo: fork.intersectionIndex };\n  }\n\n  return { type: 'tryOtherMove' };\n}\n","import { TicTacToeContext } from './TicTacToe.common';\n\nexport const TicTacToeStateNodes = {\n  settingUp: '@/settingUp',\n  playing: '@/playing',\n  playingTakingTurn: '@/playing/takingTurn',\n  playingCheckingGameState: '@/playing/checkingGameState',\n  showingGameEndResults: '@/showingGameEndResults',\n} as const;\n\nexport type TicTacToeState = {\n  context: TicTacToeContext;\n  value:\n    | typeof TicTacToeStateNodes.settingUp\n    | typeof TicTacToeStateNodes.playing\n    | { playing: typeof TicTacToeStateNodes.playingTakingTurn }\n    | { playing: typeof TicTacToeStateNodes.playingCheckingGameState }\n    | typeof TicTacToeStateNodes.showingGameEndResults;\n};\n\nexport const TicTacToeMachineActions = {\n  setPlayer: 'setPlayer',\n  setTurnOrder: 'setTurnOrder',\n  setTransitionDelay: 'setTransitionDelay',\n  awaitTurn: 'awaitTurn',\n  tryGameEnd: 'tryGameEnd',\n  saveTurn: 'saveTurn',\n  saveSurrender: 'saveSurrender',\n  switchTurn: 'switchTurn',\n  revertContextToInitial: 'revertContextToInitial',\n  revertContextButOpponents: 'revertContextButOpponents',\n} as const;\n\nexport const TicTacToeMachineConditions = {\n  verifyTurn: 'verifyTurn',\n  verifyGameEnd: 'verifyGameEnd',\n} as const;\n","import { createMachine, assign, spawn } from 'xstate';\n\nimport { createTicTacToeActor } from './TicTacToe.actor';\nimport {\n  TicTacToeActorEventTypes as Msg,\n  PLAYER_TYPE,\n  PlayerContext,\n  FieldContext,\n  FIELD_INITIAL,\n  PLAYER_SYMBOL,\n  TicTacToeEvents,\n  TicTacToeEventTypes as E,\n  PLAYER_NUM,\n  TicTacToeContext,\n  FIELD,\n  TIC_TAC_TOE_DELAY_OPTIONS,\n} from './TicTacToe.common';\n\nimport {\n  TicTacToeState,\n  TicTacToeStateNodes as S,\n  TicTacToeMachineActions as A,\n  TicTacToeMachineConditions as C,\n} from './TicTacToe.machine.types';\n\nconst initialContext: TicTacToeContext = {\n  actorTransitionDelay: TIC_TAC_TOE_DELAY_OPTIONS.default,\n  opponents: {\n    [PLAYER_NUM.player1]: { type: PLAYER_TYPE.user, symbol: PLAYER_SYMBOL.x },\n    [PLAYER_NUM.player2]: { type: PLAYER_TYPE.user, symbol: PLAYER_SYMBOL.o },\n  },\n  turnOrder: {\n    current: PLAYER_NUM.player1,\n    turnsMade: 0,\n  },\n  field: FIELD_INITIAL,\n  winCombo: null,\n  surrendered: null,\n};\n\n/**\n * This machine defines major states of the game\n */\nexport const TicTacToeMachine = createMachine<TicTacToeContext, TicTacToeEvents, TicTacToeState>(\n  {\n    context: initialContext,\n    initial: S.settingUp,\n    states: {\n      /**\n       * We need to setup the game: set players; decide turn-order\n       */\n      [S.settingUp]: {\n        on: {\n          [E.CHANGE_PLAYER_REQ]: { actions: [A.setPlayer] },\n          [E.CHANGE_TURN_ORDER_REQ]: { actions: [A.setTurnOrder] },\n          [E.CHANGE_TRANSITION_DELAY_REQ]: { actions: [A.setTransitionDelay] },\n          [E.CONTINUE_REQ]: {\n            target: S.playing,\n          },\n        },\n      },\n      /**\n       * While playing we will:\n       */\n      [S.playing]: {\n        initial: S.playingTakingTurn,\n        states: {\n          /**\n           * - wait for their turn\n           * - accept or force to turn again\n           */\n          [S.playingTakingTurn]: {\n            entry: A.awaitTurn,\n            on: {\n              [E.ACCEPT_TURN_REQ]: [\n                {\n                  target: S.playingCheckingGameState,\n                  actions: [A.saveTurn, A.switchTurn],\n                  cond: C.verifyTurn,\n                },\n                {\n                  target: S.playingCheckingGameState,\n                },\n              ],\n              [E.GIVE_UP_TURN_REQ]: {\n                target: `#${S.showingGameEndResults}`,\n                actions: [A.saveSurrender],\n              },\n            },\n          },\n          /**\n           * - decide if the game has ended\n           * - or ask other player to move\n           */\n          [S.playingCheckingGameState]: {\n            entry: A.tryGameEnd,\n            always: [\n              {\n                target: `#${S.showingGameEndResults}`,\n                cond: C.verifyGameEnd,\n              },\n              {\n                target: S.playingTakingTurn,\n              },\n            ],\n          },\n        },\n      },\n      /**\n       * We need to show the results\n       * - we should ask if players want to retry\n       */\n      [S.showingGameEndResults]: {\n        id: S.showingGameEndResults,\n        on: {\n          [E.RETRY_REQ]: {\n            target: S.playing,\n            actions: [A.revertContextButOpponents],\n          },\n          [E.SET_UP_NEW_GAME]: {\n            target: S.settingUp,\n            actions: [A.revertContextToInitial],\n          },\n        },\n      },\n    },\n  },\n  {\n    guards: {\n      [C.verifyTurn]: ({ field }, event) => {\n        if (event.type === E.ACCEPT_TURN_REQ) {\n          return field[event.index] === null;\n        }\n        return false;\n      },\n      [C.verifyGameEnd]: ({ winCombo, surrendered, turnOrder }) => {\n        return Boolean(winCombo || surrendered) || turnOrder.turnsMade === 9;\n      },\n    },\n    actions: {\n      /**\n       * Reverting context to initial\n       */\n      [A.revertContextToInitial]: assign({ ...initialContext }),\n      [A.revertContextButOpponents]: assign((ctx) => ({\n        ...initialContext,\n        opponents: ctx.opponents,\n        actorTransitionDelay: ctx.actorTransitionDelay,\n      })),\n\n      /**\n       * Setting a player to be controlled by a user or an agent\n       */\n      [A.setPlayer]: assign({\n        opponents: (ctx, event) => {\n          if (event.type === E.CHANGE_PLAYER_REQ) {\n            // stop old agent if exists\n            const currentPlayerInfo: PlayerContext = ctx.opponents[event.kind];\n            if (currentPlayerInfo.type === PLAYER_TYPE.agent) {\n              currentPlayerInfo.ref.stop?.();\n            }\n\n            // spawn a new one if needed\n            const newPlayerSymbol = (() => {\n              if (event.kind === PLAYER_NUM.player1) {\n                const player1Symbol: TicTacToeContext['opponents']['player1']['symbol'] = PLAYER_SYMBOL.x;\n                return player1Symbol;\n              }\n\n              const player2Symbol: TicTacToeContext['opponents']['player2']['symbol'] = PLAYER_SYMBOL.o;\n              return player2Symbol;\n            })();\n\n            const newPlayerInfo: TicTacToeContext['opponents']['player1'] | TicTacToeContext['opponents']['player2'] =\n              event.value === PLAYER_TYPE.user\n                ? {\n                    type: PLAYER_TYPE.user,\n                    symbol: newPlayerSymbol,\n                  }\n                : {\n                    type: PLAYER_TYPE.agent,\n                    ref: spawn(createTicTacToeActor(newPlayerSymbol), { name: event.kind }),\n                    symbol: newPlayerSymbol,\n                  };\n\n            return {\n              ...ctx.opponents,\n              [event.kind]: newPlayerInfo,\n            };\n          }\n\n          return ctx.opponents;\n        },\n      }),\n\n      /**\n       * Setting who plays on the current turn\n       */\n      [A.setTurnOrder]: assign({\n        turnOrder: (ctx, event) => {\n          if (event.type === E.CHANGE_TURN_ORDER_REQ) {\n            return {\n              ...ctx.turnOrder,\n              current: event.first,\n            };\n          }\n\n          return ctx.turnOrder;\n        },\n      }),\n\n      /**\n       * Setting a transition delay for actors\n       */\n      [A.setTransitionDelay]: assign({\n        actorTransitionDelay: (ctx, event) => {\n          if (event.type === E.CHANGE_TRANSITION_DELAY_REQ) {\n            return event.delay;\n          }\n\n          return ctx.actorTransitionDelay;\n        },\n      }),\n\n      /**\n       * Sending a message to an agent or waiting for a user to move\n       */\n      [A.awaitTurn]: (ctx) => {\n        const player = ctx.opponents[ctx.turnOrder.current];\n        if (player.type === PLAYER_TYPE.agent) {\n          player.ref.send({\n            type: Msg.MAKE_TURN_REQ,\n            field: ctx.field,\n            player: ctx.turnOrder.current,\n            transitionDelay: ctx.actorTransitionDelay,\n          });\n        } else {\n          // just waiting for a user to make their move\n        }\n      },\n\n      /**\n       * Saving current turn to context\n       */\n      [A.saveTurn]: assign({\n        field: (ctx, event) => {\n          if (event.type === E.ACCEPT_TURN_REQ) {\n            const newField: FieldContext = [...ctx.field];\n            const newSymbol = ctx.opponents[event.sender].symbol;\n            newField[event.index] = newSymbol;\n            return newField;\n          }\n\n          return ctx.field;\n        },\n      }),\n\n      /**\n       * Saving surrender signal when player throws a game\n       */\n      [A.saveSurrender]: assign({\n        surrendered: (ctx) => {\n          return ctx.turnOrder.current;\n        },\n      }),\n\n      [A.tryGameEnd]: assign({\n        winCombo: ({ field, winCombo }) => {\n          const someCombo = FIELD.COMBINATIONS.find((combination) => {\n            const [a, b, c] = combination;\n            if (field[a] && field[a] === field[b] && field[a] === field[c]) {\n              return true;\n            }\n            return false;\n          });\n\n          const hasFreeSpace = field.some((cellValue) => cellValue === null);\n          if (someCombo || !hasFreeSpace) {\n            return someCombo as TicTacToeContext['winCombo'];\n          }\n          return winCombo;\n        },\n      }),\n\n      /**\n       * Switch to other player\n       */\n      [A.switchTurn]: assign({\n        turnOrder: (ctx) => ({\n          ...ctx.turnOrder,\n          current: ctx.turnOrder.current === PLAYER_NUM.player1 ? PLAYER_NUM.player2 : PLAYER_NUM.player1,\n          turnsMade: ctx.turnOrder.turnsMade + 1,\n        }),\n      }),\n    },\n  },\n);\n","import { useMachine } from '@xstate/react';\nimport { useEffect } from 'react';\nimport { inspect } from '@xstate/inspect';\nimport {\n  FIELD,\n  FieldCellIndex,\n  PLAYER_NUM,\n  PLAYER_TYPE,\n  TicTacToeEventTypes as E,\n  TicTacToeTransitionDelay,\n  TIC_TAC_TOE_DELAY_OPTIONS,\n} from '../features/TicTacToe.common';\nimport { TicTacToeMachine } from '../features/TicTacToe.machine';\nimport { TicTacToeStateNodes as S } from '../features/TicTacToe.machine.types';\n\ninspect({ iframe: () => document.getElementById('stately-frame') as HTMLIFrameElement });\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => {};\n\nexport const TicTacToePage: React.FC = () => {\n  const [machineState, send] = useMachine(TicTacToeMachine, { devTools: true });\n  const renderMachineState = () => {\n    switch (true) {\n      case machineState.matches(S.settingUp): {\n        return (\n          <div style={{ display: 'grid', gap: 8 }}>\n            <button style={{ minWidth: 150, height: 50 }} type=\"button\" onClick={() => send({ type: E.CONTINUE_REQ })}>\n              Player vs Player\n            </button>\n            <button\n              style={{ minWidth: 150, height: 50 }}\n              type=\"button\"\n              onClick={() => {\n                send({\n                  type: E.CHANGE_PLAYER_REQ,\n                  kind: PLAYER_NUM.player2,\n                  value: PLAYER_TYPE.agent,\n                });\n                send({ type: E.CONTINUE_REQ });\n              }}\n            >\n              Player vs AI\n            </button>\n            <button\n              style={{ minWidth: 150, height: 50 }}\n              type=\"button\"\n              onClick={() => {\n                send({\n                  type: E.CHANGE_PLAYER_REQ,\n                  kind: PLAYER_NUM.player1,\n                  value: PLAYER_TYPE.agent,\n                });\n                send({\n                  type: E.CHANGE_PLAYER_REQ,\n                  kind: PLAYER_NUM.player2,\n                  value: PLAYER_TYPE.agent,\n                });\n                send({ type: E.CONTINUE_REQ });\n              }}\n            >\n              AI vs AI\n            </button>\n            <span>\n              delay (ms) transitions <br /> to see them in inspector frame:\n            </span>\n            <select\n              defaultValue={TIC_TAC_TOE_DELAY_OPTIONS.default}\n              onChange={(e) =>\n                send({ type: E.CHANGE_TRANSITION_DELAY_REQ, delay: Number(e.target.value) as TicTacToeTransitionDelay })\n              }\n            >\n              {Object.values(TIC_TAC_TOE_DELAY_OPTIONS).map((delay) => (\n                <option value={delay}>{delay}</option>\n              ))}\n            </select>\n            <span>\n              switch from machine(x:n) <br /> to a player in inspector frame <br /> when game starts\n            </span>\n          </div>\n        );\n      }\n\n      case machineState.matches(S.playing): {\n        const currentPlayer = machineState.context.turnOrder.current;\n        const { symbol: currentPlayerSymbol } = machineState.context.opponents[currentPlayer];\n        const isPlayersTurn = machineState.context.opponents[currentPlayer].type === PLAYER_TYPE.user;\n        const isFirstTurn = machineState.context.turnOrder.turnsMade === 0;\n        const makeTurn = isPlayersTurn\n          ? (index: FieldCellIndex) => () => {\n              send({\n                type: E.ACCEPT_TURN_REQ,\n                index,\n                sender: currentPlayer,\n              });\n            }\n          : () => noop;\n\n        return (\n          <div style={{ display: 'grid', gap: 16 }}>\n            <h3>{`${currentPlayer} (${currentPlayerSymbol}) to make turn`}</h3>\n            <div\n              style={{\n                display: 'grid',\n                gridTemplateColumns: '100px 100px 100px',\n                gridTemplateRows: '100px 100px 100px',\n                gap: 8,\n              }}\n            >\n              {machineState.context.field.map((cell, index) => (\n                <div\n                  // eslint-disable-next-line react/no-array-index-key\n                  key={index}\n                  style={{\n                    outline: '1px solid gray',\n                    cursor: 'pointer',\n                    fontSize: 50,\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    backgroundColor:\n                      ((isPlayersTurn && index === FIELD.CENTER) || (isPlayersTurn && !isFirstTurn)) && cell === null\n                        ? '#cbffb6'\n                        : '#ffffff',\n                    transition: 'background .5s ease',\n                  }}\n                  role=\"button\"\n                  tabIndex={index}\n                  onKeyDown={noop}\n                  onClick={makeTurn(index as FieldCellIndex)}\n                >\n                  {cell}\n                </div>\n              ))}\n            </div>\n            {isPlayersTurn ? (\n              <button type=\"button\" onClick={() => send({ type: E.GIVE_UP_TURN_REQ })}>\n                Give up\n              </button>\n            ) : (\n              <button type=\"button\" disabled>\n                ---\n              </button>\n            )}\n          </div>\n        );\n      }\n\n      case machineState.matches(S.showingGameEndResults): {\n        return (\n          <div style={{ display: 'grid', gap: 16 }}>\n            <h3>Game ended</h3>\n            <div\n              style={{\n                display: 'grid',\n                gridTemplateColumns: '100px 100px 100px',\n                gridTemplateRows: '100px 100px 100px',\n                gap: 8,\n              }}\n            >\n              {machineState.context.field.map((cell, index) => (\n                <div\n                  // eslint-disable-next-line react/no-array-index-key\n                  key={index}\n                  title={`${index}`}\n                  style={{\n                    outline: '1px solid gray',\n                    cursor: 'pointer',\n                    fontSize: 50,\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    background: machineState.context.winCombo?.includes(index as FieldCellIndex) ? 'green' : undefined,\n                  }}\n                >\n                  {cell}\n                </div>\n              ))}\n            </div>\n            <button type=\"button\" onClick={() => send({ type: E.RETRY_REQ })}>\n              Retry\n            </button>\n            <button type=\"button\" onClick={() => send({ type: E.SET_UP_NEW_GAME })}>\n              New game\n            </button>\n            {machineState.context.winCombo && <div>{`Win combination ${machineState.context.winCombo}`}</div>}\n            {machineState.context.surrendered && <div>{`${machineState.context.surrendered} surrendered!`}</div>}\n            {!machineState.context.winCombo && !machineState.context.surrendered && <div>It`s a draw</div>}\n          </div>\n        );\n      }\n\n      default:\n        return <div>UNKNOWN STATE</div>;\n    }\n  };\n\n  useEffect(() => {\n    // eslint-disable-next-line no-console\n    console.log({\n      turn: machineState.context.turnOrder.turnsMade,\n      context: machineState.context,\n      events: machineState.events,\n      value: machineState.value,\n    });\n  });\n\n  return (\n    <div\n      style={{\n        width: '50%',\n        margin: '10% auto auto auto',\n        display: 'flex',\n        flexDirection: 'column',\n        justifyContent: 'center',\n        alignItems: 'center',\n      }}\n    >\n      {renderMachineState()}\n    </div>\n  );\n};\n","import { TicTacToePage } from '../pages/TicTacToePage';\n\nexport const App: React.FC = () => {\n  return <TicTacToePage />;\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\n\nimport { App } from './app-container';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}
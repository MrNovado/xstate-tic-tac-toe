{"version":3,"sources":["reportWebVitals.ts","features/TicTacToe.common.ts","features/TicTacToe.actor.types.ts","features/TicTacToe.actor.business.ts","features/TicTacToe.actor.ts","features/TicTacToe.machine.types.ts","features/TicTacToe.machine.ts","pages/TicTacToePage.tsx","app-container/App.tsx","index.tsx"],"names":["reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","PLAYER_TYPE","PLAYER_NUM","PLAYER_SYMBOL","ROWS","COLUMNS","DIAGONALS","FIELD","CORNERS","TOP_LEFT","TOP_RIGHT","BOT_LEFT","BOT_RIGHT","EDGES","TOP","LEFT","RIGHT","BOT","CENTER","COMBINATIONS","FIELD_INITIAL","TicTacToeEventTypes","TicTacToeActorEventTypes","TicTacToeActorStateNodes","TicTacToeActorConditions","TicTacToeActorActions","getOpponent","symbol","MAKING_TURN_ACTION","target","S","cond","C","createTicTacToeActor","givenSymbol","createMachine","context","field","player","moveReady","initial","states","on","E","actions","A","always","entry","guards","type","assign","_","event","sendParent","Msg","index","turnTo","sender","delay","assesWinning","assesForking","opponent","possibleOppositeCorners","is","filter","inv","oppositeCorner","sample","possibleFreeCorners","value","corner","freeCorner","possibleFreeSides","side","freeSide","combination","find","row","reduce","acc","find2InARowWith1Free","undefined","fork","oneTakenAnd2Blanks","line","rows","columns","diagonals","length","intersection","intersectionEmpty","intersectionIndex","column","findAFork","TicTacToeStateNodes","TicTacToeMachineActions","TicTacToeMachineConditions","initialContext","opponents","turnOrder","current","turnsMade","winCombo","surrendered","TicTacToeMachine","id","Boolean","ctx","currentPlayerInfo","kind","ref","stop","newPlayerSymbol","newPlayerInfo","spawn","name","first","send","newField","newSymbol","someCombo","a","b","c","hasFreeSpace","some","cellValue","inspect","iframe","noop","TicTacToePage","useMachine","devTools","machineState","useEffect","console","log","turn","events","style","width","margin","display","flexDirection","justifyContent","alignItems","matches","gap","minWidth","height","onClick","currentPlayer","currentPlayerSymbol","isPlayersTurn","makeTurn","gridTemplateColumns","gridTemplateRows","map","cell","outline","cursor","fontSize","role","tabIndex","onKeyDown","disabled","title","background","includes","renderMachineState","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b7ceec0c.chunk.js","sourcesContent":["// eslint-disable-next-line\n// @ts-ignore\nimport { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler): void => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import { ActorRef } from 'xstate';\n\nexport const PLAYER_TYPE = {\n  user: 'user',\n  agent: 'agent',\n} as const;\n\nexport type PlayerContext =\n  | { type: typeof PLAYER_TYPE.user }\n  | {\n      type: typeof PLAYER_TYPE.agent;\n      ref: ActorRef<TicTacToeActorEvents>;\n    };\n\nexport const PLAYER_NUM = {\n  player1: 'player1',\n  player2: 'player2',\n} as const;\n\nexport type PlayerTurnContext = typeof PLAYER_NUM[keyof typeof PLAYER_NUM];\n\nexport const PLAYER_SYMBOL = {\n  x: 'x',\n  o: '0',\n} as const;\n\nexport type PlayerFieldSymbol = typeof PLAYER_SYMBOL[keyof typeof PLAYER_SYMBOL];\n\ntype FieldCellValue = PlayerFieldSymbol | null;\nexport type FieldCellIndex = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\n\n// strictly 9 cells\nexport type FieldContext = [\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n  FieldCellValue,\n];\n\nexport const ROWS: FieldCellIndex[][] = [\n  [0, 1, 2],\n  [3, 4, 5],\n  [6, 7, 8],\n];\n\nexport const COLUMNS: FieldCellIndex[][] = [\n  [0, 3, 6],\n  [1, 4, 7],\n  [2, 5, 8],\n];\n\nexport const DIAGONALS: FieldCellIndex[][] = [\n  [0, 4, 8],\n  [2, 4, 6],\n];\n\nexport const FIELD = {\n  CORNERS: {\n    TOP_LEFT: 0 as FieldCellIndex,\n    TOP_RIGHT: 2 as FieldCellIndex,\n    BOT_LEFT: 6 as FieldCellIndex,\n    BOT_RIGHT: 8 as FieldCellIndex,\n  },\n  EDGES: {\n    TOP: 1 as FieldCellIndex,\n    LEFT: 3 as FieldCellIndex,\n    RIGHT: 5 as FieldCellIndex,\n    BOT: 7 as FieldCellIndex,\n  },\n  CENTER: 4 as FieldCellIndex,\n  COMBINATIONS: [...ROWS, ...COLUMNS, ...DIAGONALS],\n  ROWS,\n  COLUMNS,\n  DIAGONALS,\n};\n\nexport const FIELD_INITIAL: FieldContext = [null, null, null, null, null, null, null, null, null];\n\nexport const TicTacToeEventTypes = {\n  CHANGE_PLAYER_REQ: 'CHANGE_PLAYER_REQ',\n  CONTINUE_REQ: 'CONTINUE_REQ',\n  CHANGE_TURN_ORDER_REQ: 'CHANGE_TURN_ORDER_REQ',\n  ACCEPT_TURN_REQ: 'ACCEPT_TURN_REQ',\n  GIVE_UP_TURN_REQ: 'GIVE_UP_TURN_REQ',\n  RETRY_REQ: 'RETRY_REQ',\n  SET_UP_NEW_GAME: 'SET_UP_NEW_GAME',\n} as const;\n\nexport type TicTacToeEvents =\n  | { type: typeof TicTacToeEventTypes.CHANGE_PLAYER_REQ; kind: PlayerTurnContext; value: PlayerContext['type'] }\n  | { type: typeof TicTacToeEventTypes.CONTINUE_REQ }\n  | { type: typeof TicTacToeEventTypes.CHANGE_TURN_ORDER_REQ; first: PlayerTurnContext }\n  | { type: typeof TicTacToeEventTypes.ACCEPT_TURN_REQ; index: FieldCellIndex; sender: PlayerTurnContext }\n  | { type: typeof TicTacToeEventTypes.GIVE_UP_TURN_REQ }\n  | { type: typeof TicTacToeEventTypes.RETRY_REQ }\n  | { type: typeof TicTacToeEventTypes.SET_UP_NEW_GAME };\n\nexport type TicTacToeContext = {\n  opponents: {\n    [PLAYER_NUM.player1]: PlayerContext & { symbol: Extract<PlayerFieldSymbol, typeof PLAYER_SYMBOL.x> };\n    [PLAYER_NUM.player2]: PlayerContext & { symbol: Extract<PlayerFieldSymbol, typeof PLAYER_SYMBOL.o> };\n  };\n\n  turnOrder: {\n    current: PlayerTurnContext;\n    turnsMade: number;\n  };\n\n  field: FieldContext;\n\n  // TODO: strictly 3 unique indexes?\n  winCombo: [FieldCellIndex, FieldCellIndex, FieldCellIndex] | null;\n  surrendered: PlayerTurnContext | null;\n};\n\nexport const TicTacToeActorEventTypes = {\n  MAKE_TURN_REQ: 'MAKE_TURN_REQ',\n} as const;\n\n// Machine to Actor -- Msg\nexport type TicTacToeActorEvents = {\n  type: typeof TicTacToeActorEventTypes.MAKE_TURN_REQ;\n  field: FieldContext;\n  player: PlayerTurnContext;\n};\n","import { PlayerFieldSymbol, FieldCellIndex, TicTacToeContext, PlayerTurnContext } from './TicTacToe.common';\n\nexport type TicTacToeActorContext = {\n  field: TicTacToeContext['field'];\n  player: PlayerTurnContext;\n  symbol: PlayerFieldSymbol;\n  moveReady: { type: 'commit'; turnTo: FieldCellIndex } | { type: 'tryOtherMove' } | null;\n};\n\nexport const TicTacToeActorStateNodes = {\n  awaitingTurn: '@/awaitingTurn',\n  makingTurn: '@/makingTurn',\n  tryingToWin: '@/tryingToWin',\n  tryingToBlockWin: '@/tryingToBlockWin',\n  tryingToFork: '@/tryingToFork',\n  tryingToBlockFork: '@/tryingToBlockFork',\n  tryingToTakeCenter: '@/tryingToTakeCenter',\n  tryingToTakeOppositeCorner: '@/tryingToTakeOppositeCorner',\n  tryingToTakeCorner: '@/tryingToTakeCorner',\n  tryingToTakeEmptySide: '@/tryingToTakeEmptySide',\n  givingUp: '@/givingUp',\n} as const;\n\nexport type TicTacToeActorState = {\n  context: TicTacToeActorContext;\n  value:\n    | typeof TicTacToeActorStateNodes.awaitingTurn\n    | typeof TicTacToeActorStateNodes.makingTurn\n    | typeof TicTacToeActorStateNodes.tryingToWin\n    | typeof TicTacToeActorStateNodes.tryingToBlockWin\n    | typeof TicTacToeActorStateNodes.tryingToFork\n    | typeof TicTacToeActorStateNodes.tryingToBlockFork\n    | typeof TicTacToeActorStateNodes.tryingToTakeCenter\n    | typeof TicTacToeActorStateNodes.tryingToTakeOppositeCorner\n    | typeof TicTacToeActorStateNodes.tryingToTakeCorner\n    | typeof TicTacToeActorStateNodes.tryingToTakeEmptySide\n    | typeof TicTacToeActorStateNodes.givingUp;\n};\n\nexport const TicTacToeActorConditions = {\n  verifyTurnReady: 'verifyTurnReady',\n} as const;\n\nexport const TicTacToeActorActions = {\n  saveField: 'saveField',\n  makeTurn: 'makeTurn',\n  assesWinning: 'assesWinning',\n  assesBlockingWin: 'assesBlockingWin',\n  assesForking: 'assesForking',\n  assesBlockingFork: 'assesBlockingFork',\n  assesTakingCenter: 'assesTakingCenter',\n  assesTakingOppositeCorner: 'assesTakingOppositeCorner',\n  assesTakingCorner: 'assesTakingCorner',\n  assesTakingSide: 'assesTakingSide',\n  giveUp: 'giveUp',\n} as const;\n","import {\n  PlayerFieldSymbol,\n  PLAYER_SYMBOL,\n  FieldContext,\n  FIELD,\n  FieldCellIndex,\n  ROWS,\n  COLUMNS,\n  DIAGONALS,\n} from './TicTacToe.common';\n\nexport function getOpponent(symbol: PlayerFieldSymbol): PlayerFieldSymbol {\n  return symbol === PLAYER_SYMBOL.x ? PLAYER_SYMBOL.o : PLAYER_SYMBOL.x;\n}\n\nexport function find2InARowWith1Free(field: FieldContext, symbol: PlayerFieldSymbol): FieldCellIndex[] | undefined {\n  const opponent = getOpponent(symbol);\n  const twoInARow = FIELD.COMBINATIONS.find((row) => {\n    const actorSymbolsInARow = row.reduce<number>((acc, index) => {\n      if (field[index] === symbol) {\n        return acc + 1;\n      }\n\n      if (field[index] === opponent) {\n        return acc - 1;\n      }\n\n      return acc;\n    }, 0);\n\n    return actorSymbolsInARow === 2;\n  });\n\n  return twoInARow;\n}\n\nexport function findAFork(\n  field: FieldContext,\n  symbol: PlayerFieldSymbol,\n): { intersectionIndex: FieldCellIndex } | null {\n  // if there are two intersecting rows, columns, or diagonals\n  // with one of my pieces and two blanks,\n  // =====================================\n  //  [*,X,*]\n  //  [X,_,_] <- 2 blanks on row 2\n  //  [*,_,*]\n  //     ^- 2 blanks on col 2\n  //  cell 4 (center) is an intersection\n  // =====================================\n  // and if the intersecting space is empty\n  const oneTakenAnd2Blanks = (line: FieldCellIndex[]) => {\n    const howManyTaken = line.reduce<number>((acc, index) => {\n      if (field[index] === symbol) {\n        return acc + 1;\n      }\n\n      if (field[index] === null) {\n        return acc;\n      }\n\n      return acc - 1;\n    }, 0);\n\n    return howManyTaken === 1;\n  };\n\n  const rows = ROWS.filter(oneTakenAnd2Blanks);\n  const columns = COLUMNS.filter(oneTakenAnd2Blanks);\n  const diagonals = DIAGONALS.filter(oneTakenAnd2Blanks);\n\n  // scanning rows-first\n  if (rows.length) {\n    for (const row of rows) {\n      for (const index of row) {\n        // against columns\n        for (const column of columns) {\n          const intersection = index in column;\n          const intersectionEmpty = field[index] === null;\n          if (intersection && intersectionEmpty) {\n            return {\n              intersectionIndex: index,\n            };\n          }\n        }\n\n        // against diagonals\n        for (const diag of diagonals) {\n          const intersection = index in diag;\n          const intersectionEmpty = field[index] === null;\n          if (intersection && intersectionEmpty) {\n            return {\n              intersectionIndex: index,\n            };\n          }\n        }\n      }\n    }\n  }\n\n  // scanning columns-first\n  if (columns.length) {\n    for (const column of columns) {\n      for (const index of column) {\n        // against diagonals\n        // (already scanned against rows if they were available)\n        for (const diag of diagonals) {\n          const intersection = index in diag;\n          const intersectionEmpty = field[index] === null;\n          if (intersection && intersectionEmpty) {\n            return {\n              intersectionIndex: index,\n            };\n          }\n        }\n      }\n    }\n  }\n\n  // 2 diagonals can only intersect in the center\n  if (diagonals.length === 2 && field[FIELD.CENTER] === null) {\n    return { intersectionIndex: FIELD.CENTER };\n  }\n\n  return null;\n}\n","import { createMachine, StateMachine, assign, sendParent } from 'xstate';\n\nimport sample from 'lodash.sample';\n\nimport {\n  TicTacToeActorEvents,\n  TicTacToeActorEventTypes as E,\n  TicTacToeEventTypes as Msg,\n  TicTacToeEvents,\n  FIELD_INITIAL,\n  PlayerFieldSymbol,\n  TicTacToeEventTypes,\n  FIELD,\n  FieldContext,\n  PLAYER_NUM,\n} from './TicTacToe.common';\nimport {\n  TicTacToeActorContext,\n  TicTacToeActorState,\n  TicTacToeActorActions as A,\n  TicTacToeActorConditions as C,\n  TicTacToeActorStateNodes as S,\n} from './TicTacToe.actor.types';\nimport { getOpponent, find2InARowWith1Free, findAFork } from './TicTacToe.actor.business';\n\nconst MAKING_TURN_ACTION = {\n  target: S.makingTurn,\n  cond: C.verifyTurnReady,\n} as const;\n\nconst MSG_DELAY = 300;\n\n/**\n * This machine defines actor' states using\n * Newell and Simon's expert model with rule ordering:\n *\n * - https://en.wikipedia.org/wiki/Tic-tac-toe#Combinatorics\n * - https://en.wikipedia.org/wiki/Tic-tac-toe#Strategy\n * - https://doi.org/10.1016%2F0364-0213%2893%2990003-Q\n */\nexport const createTicTacToeActor = (\n  givenSymbol: PlayerFieldSymbol,\n): StateMachine<TicTacToeActorContext, Record<string, unknown>, TicTacToeActorEvents, TicTacToeActorState> =>\n  createMachine<TicTacToeActorContext, TicTacToeActorEvents, TicTacToeActorState>(\n    {\n      context: {\n        field: FIELD_INITIAL,\n        player: PLAYER_NUM.player2,\n        symbol: givenSymbol,\n        moveReady: null,\n      },\n      initial: S.awaitingTurn,\n      states: {\n        [S.awaitingTurn]: {\n          on: {\n            [E.MAKE_TURN_REQ]: {\n              target: S.tryingToWin,\n              actions: [A.saveField],\n            },\n          },\n        },\n\n        [S.makingTurn]: {\n          always: [\n            {\n              target: S.awaitingTurn,\n              actions: A.makeTurn,\n            },\n          ],\n        },\n\n        [S.tryingToWin]: {\n          entry: A.assesWinning,\n          always: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToBlockWin,\n            },\n          ],\n        },\n        [S.tryingToBlockWin]: {\n          entry: A.assesBlockingWin,\n          always: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToFork,\n            },\n          ],\n        },\n        [S.tryingToFork]: {\n          entry: A.assesForking,\n          always: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToBlockFork,\n            },\n          ],\n        },\n        [S.tryingToBlockFork]: {\n          entry: A.assesBlockingFork,\n          always: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToTakeCenter,\n            },\n          ],\n        },\n        [S.tryingToTakeCenter]: {\n          entry: A.assesTakingCenter,\n          always: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToTakeOppositeCorner,\n            },\n          ],\n        },\n        [S.tryingToTakeOppositeCorner]: {\n          entry: A.assesTakingOppositeCorner,\n          always: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToTakeCorner,\n            },\n          ],\n        },\n        [S.tryingToTakeCorner]: {\n          entry: A.assesTakingCorner,\n          always: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.tryingToTakeEmptySide,\n            },\n          ],\n        },\n        [S.tryingToTakeEmptySide]: {\n          entry: A.assesTakingSide,\n          always: [\n            MAKING_TURN_ACTION,\n            {\n              target: S.givingUp,\n            },\n          ],\n        },\n\n        [S.givingUp]: {\n          always: [\n            {\n              target: S.awaitingTurn,\n              actions: A.giveUp,\n            },\n          ],\n        },\n      },\n    },\n    {\n      guards: {\n        [C.verifyTurnReady]: ({ moveReady }: TicTacToeActorContext) => moveReady?.type === 'commit',\n      },\n      actions: {\n        /**\n         * CHILD-PARENT Msg ===================================================\n         */\n\n        [A.saveField]: assign({\n          player: (_, event) => event.player,\n          field: (_, event) => event.field,\n        }),\n\n        [A.makeTurn]: sendParent(\n          ({\n            player,\n            moveReady,\n          }): Extract<\n            TicTacToeEvents,\n            { type: typeof TicTacToeEventTypes.ACCEPT_TURN_REQ | typeof TicTacToeEventTypes.GIVE_UP_TURN_REQ }\n          > => {\n            if (moveReady?.type === 'commit') {\n              return { type: Msg.ACCEPT_TURN_REQ, index: moveReady.turnTo, sender: player };\n            }\n\n            return { type: Msg.GIVE_UP_TURN_REQ };\n          },\n          { delay: MSG_DELAY },\n        ),\n\n        [A.giveUp]: sendParent(\n          (): Extract<TicTacToeEvents, { type: typeof TicTacToeEventTypes.GIVE_UP_TURN_REQ }> => {\n            return { type: Msg.GIVE_UP_TURN_REQ };\n          },\n          { delay: MSG_DELAY },\n        ),\n\n        /**\n         * ACTOR BUSINESS =====================================================\n         */\n\n        [A.assesWinning]: assign({\n          moveReady: ({ field, symbol }) => {\n            return assesWinning(field, symbol);\n          },\n        }),\n        [A.assesBlockingWin]: assign({\n          moveReady: ({ field, symbol }) => {\n            const opponentSymbol = getOpponent(symbol);\n            return assesWinning(field, opponentSymbol);\n          },\n        }),\n        [A.assesForking]: assign({\n          moveReady: ({ field, symbol }) => {\n            return assesForking(field, symbol);\n          },\n        }),\n        [A.assesBlockingFork]: assign({\n          moveReady: ({ field, symbol }) => {\n            const opponentSymbol = getOpponent(symbol);\n            return assesForking(field, opponentSymbol);\n          },\n        }),\n        [A.assesTakingCenter]: assign({\n          moveReady: ({ field }) => {\n            if (field[FIELD.CENTER] === null) {\n              return { type: 'commit', turnTo: FIELD.CENTER };\n            }\n\n            return { type: 'tryOtherMove' };\n          },\n        }),\n        [A.assesTakingOppositeCorner]: assign({\n          moveReady: ({ field, symbol }) => {\n            const opponent = getOpponent(symbol);\n            // if my opponent is in a corner, and\n            // if the opposite corner is empty\n            const corners = [\n              {\n                is: field[FIELD.CORNERS.TOP_LEFT] === opponent && field[FIELD.CORNERS.BOT_RIGHT] === null,\n                index: FIELD.CORNERS.BOT_RIGHT,\n              },\n              {\n                is: field[FIELD.CORNERS.TOP_RIGHT] === opponent && field[FIELD.CORNERS.BOT_LEFT] === null,\n                index: FIELD.CORNERS.BOT_LEFT,\n              },\n              {\n                is: field[FIELD.CORNERS.BOT_LEFT] === opponent && field[FIELD.CORNERS.TOP_RIGHT] === null,\n                index: FIELD.CORNERS.TOP_RIGHT,\n              },\n              {\n                is: field[FIELD.CORNERS.BOT_RIGHT] === opponent && field[FIELD.CORNERS.TOP_LEFT] === null,\n                index: FIELD.CORNERS.TOP_LEFT,\n              },\n            ];\n\n            const possibleOppositeCorners = corners.filter((inv) => inv.is);\n            const oppositeCorner = sample(possibleOppositeCorners);\n            if (oppositeCorner) {\n              return { type: 'commit', turnTo: oppositeCorner.index };\n            }\n\n            return { type: 'tryOtherMove' };\n          },\n        }),\n        [A.assesTakingCorner]: assign({\n          moveReady: ({ field }) => {\n            const corners = [\n              { value: field[FIELD.CORNERS.TOP_LEFT], index: FIELD.CORNERS.TOP_LEFT },\n              { value: field[FIELD.CORNERS.TOP_RIGHT], index: FIELD.CORNERS.TOP_RIGHT },\n              { value: field[FIELD.CORNERS.BOT_LEFT], index: FIELD.CORNERS.BOT_LEFT },\n              { value: field[FIELD.CORNERS.BOT_RIGHT], index: FIELD.CORNERS.BOT_RIGHT },\n            ];\n\n            const possibleFreeCorners = corners.filter((corner) => corner.value === null);\n            const freeCorner = sample(possibleFreeCorners);\n            if (freeCorner) {\n              return { type: 'commit', turnTo: freeCorner.index };\n            }\n\n            return { type: 'tryOtherMove' };\n          },\n        }),\n        [A.assesTakingSide]: assign({\n          moveReady: ({ field }) => {\n            const sides = [\n              { value: field[FIELD.EDGES.TOP], index: FIELD.EDGES.TOP },\n              { value: field[FIELD.EDGES.LEFT], index: FIELD.EDGES.LEFT },\n              { value: field[FIELD.EDGES.RIGHT], index: FIELD.EDGES.RIGHT },\n              { value: field[FIELD.EDGES.BOT], index: FIELD.EDGES.BOT },\n            ];\n\n            const possibleFreeSides = sides.filter((side) => side.value === null);\n            const freeSide = sample(possibleFreeSides);\n            if (freeSide) {\n              return { type: 'commit', turnTo: freeSide.index };\n            }\n\n            return { type: 'tryOtherMove' };\n          },\n        }),\n      },\n    },\n  );\n\n/*\n * COMMON ACTIONS =============================================================\n */\n\nfunction assesWinning(field: FieldContext, symbol: PlayerFieldSymbol): TicTacToeActorContext['moveReady'] {\n  const combination = find2InARowWith1Free(field, symbol);\n  const turnTo = combination?.find((index) => field[index] === null);\n  if (turnTo !== undefined) {\n    return { type: 'commit', turnTo };\n  }\n\n  return { type: 'tryOtherMove' };\n}\n\nfunction assesForking(field: FieldContext, symbol: PlayerFieldSymbol): TicTacToeActorContext['moveReady'] {\n  const fork = findAFork(field, symbol);\n  if (fork) {\n    return { type: 'commit', turnTo: fork.intersectionIndex };\n  }\n\n  return { type: 'tryOtherMove' };\n}\n","import { TicTacToeContext } from './TicTacToe.common';\n\nexport const TicTacToeStateNodes = {\n  settingUp: '@/settingUp',\n  playing: '@/playing',\n  playingTakingTurn: '@/playing/takingTurn',\n  playingCheckingGameState: '@/playing/checkingGameState',\n  showingGameEndResults: '@/showingGameEndResults',\n} as const;\n\nexport type TicTacToeState = {\n  context: TicTacToeContext;\n  value:\n    | typeof TicTacToeStateNodes.settingUp\n    | typeof TicTacToeStateNodes.playing\n    | { playing: typeof TicTacToeStateNodes.playingTakingTurn }\n    | { playing: typeof TicTacToeStateNodes.playingCheckingGameState }\n    | typeof TicTacToeStateNodes.showingGameEndResults;\n};\n\nexport const TicTacToeMachineActions = {\n  setPlayer: 'setPlayer',\n  setTurnOrder: 'setTurnOrder',\n  awaitTurn: 'awaitTurn',\n  assesGameEnd: 'assesGameEnd',\n  saveTurn: 'saveTurn',\n  saveSurrender: 'saveSurrender',\n  switchTurn: 'switchTurn',\n  revertContextToInitial: 'revertContextToInitial',\n  revertContextButOpponents: 'revertContextButOpponents',\n} as const;\n\nexport const TicTacToeMachineConditions = {\n  verifyTurn: 'verifyTurn',\n  verifyGameEnd: 'verifyGameEnd',\n} as const;\n","import { createMachine, assign, spawn } from 'xstate';\n\nimport { createTicTacToeActor } from './TicTacToe.actor';\nimport {\n  TicTacToeActorEventTypes as Msg,\n  PLAYER_TYPE,\n  PlayerContext,\n  FieldContext,\n  FIELD_INITIAL,\n  PLAYER_SYMBOL,\n  TicTacToeEvents,\n  TicTacToeEventTypes as E,\n  PLAYER_NUM,\n  TicTacToeContext,\n  FIELD,\n} from './TicTacToe.common';\n\nimport {\n  TicTacToeState,\n  TicTacToeStateNodes as S,\n  TicTacToeMachineActions as A,\n  TicTacToeMachineConditions as C,\n} from './TicTacToe.machine.types';\n\nconst initialContext: TicTacToeContext = {\n  opponents: {\n    [PLAYER_NUM.player1]: { type: PLAYER_TYPE.user, symbol: PLAYER_SYMBOL.x },\n    [PLAYER_NUM.player2]: { type: PLAYER_TYPE.user, symbol: PLAYER_SYMBOL.o },\n  },\n  turnOrder: {\n    current: PLAYER_NUM.player1,\n    turnsMade: 0,\n  },\n  field: FIELD_INITIAL,\n  winCombo: null,\n  surrendered: null,\n};\n\n/**\n * This machine defines major states of the game\n */\nexport const TicTacToeMachine = createMachine<TicTacToeContext, TicTacToeEvents, TicTacToeState>(\n  {\n    context: initialContext,\n    initial: S.settingUp,\n    states: {\n      /**\n       * We need to setup the game: set players; decide turn-order\n       */\n      [S.settingUp]: {\n        on: {\n          [E.CHANGE_PLAYER_REQ]: { actions: [A.setPlayer] },\n          [E.CHANGE_TURN_ORDER_REQ]: { actions: [A.setTurnOrder] },\n          [E.CONTINUE_REQ]: {\n            target: S.playing,\n          },\n        },\n      },\n      /**\n       * While playing we will:\n       */\n      [S.playing]: {\n        initial: S.playingTakingTurn,\n        states: {\n          /**\n           * - wait for their turn\n           * - accept or force to turn again\n           */\n          [S.playingTakingTurn]: {\n            entry: A.awaitTurn,\n            on: {\n              [E.ACCEPT_TURN_REQ]: [\n                {\n                  target: S.playingCheckingGameState,\n                  actions: [A.saveTurn, A.switchTurn],\n                  cond: C.verifyTurn,\n                },\n                {\n                  target: S.playingCheckingGameState,\n                },\n              ],\n              [E.GIVE_UP_TURN_REQ]: {\n                target: `#${S.showingGameEndResults}`,\n                actions: [A.saveSurrender],\n              },\n            },\n          },\n          /**\n           * - decide if the game has ended\n           * - or ask other player to move\n           */\n          [S.playingCheckingGameState]: {\n            entry: A.assesGameEnd,\n            always: [\n              {\n                target: `#${S.showingGameEndResults}`,\n                cond: C.verifyGameEnd,\n              },\n              {\n                target: S.playingTakingTurn,\n              },\n            ],\n          },\n        },\n      },\n      /**\n       * We need to show the results\n       * - we should ask if players want to retry\n       */\n      [S.showingGameEndResults]: {\n        id: S.showingGameEndResults,\n        on: {\n          [E.RETRY_REQ]: {\n            target: S.playing,\n            actions: [A.revertContextButOpponents],\n          },\n          [E.SET_UP_NEW_GAME]: {\n            target: S.settingUp,\n            actions: [A.revertContextToInitial],\n          },\n        },\n      },\n    },\n  },\n  {\n    guards: {\n      [C.verifyTurn]: ({ field }, event) => {\n        if (event.type === E.ACCEPT_TURN_REQ) {\n          return field[event.index] === null;\n        }\n        return false;\n      },\n      [C.verifyGameEnd]: ({ winCombo, surrendered, turnOrder }) => {\n        return Boolean(winCombo || surrendered) || turnOrder.turnsMade === 9;\n      },\n    },\n    actions: {\n      /**\n       * Reverting context to initial\n       */\n      [A.revertContextToInitial]: assign({ ...initialContext }),\n      [A.revertContextButOpponents]: assign((ctx) => ({ ...initialContext, opponents: ctx.opponents })),\n\n      /**\n       * Setting a player to be controlled by a user or an agent\n       */\n      [A.setPlayer]: assign({\n        opponents: (ctx, event) => {\n          if (event.type === E.CHANGE_PLAYER_REQ) {\n            // stop old agent if exists\n            const currentPlayerInfo: PlayerContext = ctx.opponents[event.kind];\n            if (currentPlayerInfo.type === PLAYER_TYPE.agent) {\n              currentPlayerInfo.ref.stop?.();\n            }\n\n            // spawn a new one if needed\n            const newPlayerSymbol = (() => {\n              if (event.kind === PLAYER_NUM.player1) {\n                const player1Symbol: TicTacToeContext['opponents']['player1']['symbol'] = PLAYER_SYMBOL.x;\n                return player1Symbol;\n              }\n\n              const player2Symbol: TicTacToeContext['opponents']['player2']['symbol'] = PLAYER_SYMBOL.o;\n              return player2Symbol;\n            })();\n\n            const newPlayerInfo: TicTacToeContext['opponents']['player1'] | TicTacToeContext['opponents']['player2'] =\n              event.value === PLAYER_TYPE.user\n                ? {\n                    type: PLAYER_TYPE.user,\n                    symbol: newPlayerSymbol,\n                  }\n                : {\n                    type: PLAYER_TYPE.agent,\n                    ref: spawn(createTicTacToeActor(newPlayerSymbol), { name: event.kind }),\n                    symbol: newPlayerSymbol,\n                  };\n\n            return {\n              ...ctx.opponents,\n              [event.kind]: newPlayerInfo,\n            };\n          }\n\n          return ctx.opponents;\n        },\n      }),\n\n      /**\n       * Setting who plays on the current turn\n       */\n      [A.setTurnOrder]: assign({\n        turnOrder: (ctx, event) => {\n          if (event.type === E.CHANGE_TURN_ORDER_REQ) {\n            return {\n              ...ctx.turnOrder,\n              current: event.first,\n            };\n          }\n\n          return ctx.turnOrder;\n        },\n      }),\n\n      /**\n       * Sending a message to an agent or waiting for a user to move\n       */\n      [A.awaitTurn]: (ctx) => {\n        const player = ctx.opponents[ctx.turnOrder.current];\n        if (player.type === PLAYER_TYPE.agent) {\n          player.ref.send({\n            type: Msg.MAKE_TURN_REQ,\n            field: ctx.field,\n            player: ctx.turnOrder.current,\n          });\n        } else {\n          // just waiting for a user to make their move\n        }\n      },\n\n      /**\n       * Saving current turn to context\n       */\n      [A.saveTurn]: assign({\n        field: (ctx, event) => {\n          if (event.type === E.ACCEPT_TURN_REQ) {\n            const newField: FieldContext = [...ctx.field];\n            const newSymbol = ctx.opponents[event.sender].symbol;\n            newField[event.index] = newSymbol;\n            return newField;\n          }\n\n          return ctx.field;\n        },\n      }),\n\n      /**\n       * Saving surrender signal when player throws a game\n       */\n      [A.saveSurrender]: assign({\n        surrendered: (ctx) => {\n          return ctx.turnOrder.current;\n        },\n      }),\n\n      [A.assesGameEnd]: assign({\n        winCombo: ({ field, winCombo }) => {\n          const someCombo = FIELD.COMBINATIONS.find((combination) => {\n            const [a, b, c] = combination;\n            if (field[a] && field[a] === field[b] && field[a] === field[c]) {\n              return true;\n            }\n            return false;\n          });\n\n          const hasFreeSpace = field.some((cellValue) => cellValue === null);\n          if (someCombo || !hasFreeSpace) {\n            return someCombo as TicTacToeContext['winCombo'];\n          }\n          return winCombo;\n        },\n      }),\n\n      /**\n       * Switch to other player\n       */\n      [A.switchTurn]: assign({\n        turnOrder: (ctx) => ({\n          ...ctx.turnOrder,\n          current: ctx.turnOrder.current === PLAYER_NUM.player1 ? PLAYER_NUM.player2 : PLAYER_NUM.player1,\n          turnsMade: ctx.turnOrder.turnsMade + 1,\n        }),\n      }),\n    },\n  },\n);\n","import { useMachine } from '@xstate/react';\nimport { useEffect } from 'react';\nimport { inspect } from '@xstate/inspect';\nimport { FieldCellIndex, PLAYER_NUM, PLAYER_TYPE, TicTacToeEventTypes } from '../features/TicTacToe.common';\nimport { TicTacToeMachine } from '../features/TicTacToe.machine';\nimport { TicTacToeStateNodes as S } from '../features/TicTacToe.machine.types';\n\ninspect({ iframe: false });\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst noop = () => {};\n\nexport const TicTacToePage: React.FC = () => {\n  const [machineState, send] = useMachine(TicTacToeMachine, { devTools: true });\n  const renderMachineState = () => {\n    switch (true) {\n      case machineState.matches(S.settingUp): {\n        return (\n          <div style={{ display: 'grid', gap: 8 }}>\n            <button\n              style={{ minWidth: 150, height: 50 }}\n              type=\"button\"\n              onClick={() => send({ type: TicTacToeEventTypes.CONTINUE_REQ })}\n            >\n              Player vs Player\n            </button>\n            <button\n              style={{ minWidth: 150, height: 50 }}\n              type=\"button\"\n              onClick={() => {\n                send({\n                  type: TicTacToeEventTypes.CHANGE_PLAYER_REQ,\n                  kind: PLAYER_NUM.player2,\n                  value: PLAYER_TYPE.agent,\n                });\n                send({ type: TicTacToeEventTypes.CONTINUE_REQ });\n              }}\n            >\n              Player vs AI\n            </button>\n            <button\n              style={{ minWidth: 150, height: 50 }}\n              type=\"button\"\n              onClick={() => {\n                send({\n                  type: TicTacToeEventTypes.CHANGE_PLAYER_REQ,\n                  kind: PLAYER_NUM.player1,\n                  value: PLAYER_TYPE.agent,\n                });\n                send({\n                  type: TicTacToeEventTypes.CHANGE_PLAYER_REQ,\n                  kind: PLAYER_NUM.player2,\n                  value: PLAYER_TYPE.agent,\n                });\n                send({ type: TicTacToeEventTypes.CONTINUE_REQ });\n              }}\n            >\n              AI vs AI\n            </button>\n          </div>\n        );\n      }\n\n      case machineState.matches(S.playing): {\n        const currentPlayer = machineState.context.turnOrder.current;\n        const { symbol: currentPlayerSymbol } = machineState.context.opponents[currentPlayer];\n        const isPlayersTurn = machineState.context.opponents[currentPlayer].type === PLAYER_TYPE.user;\n        const makeTurn = isPlayersTurn\n          ? (index: FieldCellIndex) => () => {\n              send({\n                type: TicTacToeEventTypes.ACCEPT_TURN_REQ,\n                index,\n                sender: currentPlayer,\n              });\n            }\n          : () => noop;\n\n        return (\n          <div style={{ display: 'grid', gap: 16 }}>\n            <h3>{`${currentPlayer} (${currentPlayerSymbol}) to make turn`}</h3>\n            <div\n              style={{\n                display: 'grid',\n                gridTemplateColumns: '100px 100px 100px',\n                gridTemplateRows: '100px 100px 100px',\n                gap: 8,\n              }}\n            >\n              {machineState.context.field.map((cell, index) => (\n                <div\n                  // eslint-disable-next-line react/no-array-index-key\n                  key={index}\n                  style={{\n                    outline: '1px solid gray',\n                    cursor: 'pointer',\n                    fontSize: 50,\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                  }}\n                  role=\"button\"\n                  tabIndex={index}\n                  onKeyDown={noop}\n                  onClick={makeTurn(index as FieldCellIndex)}\n                >\n                  {cell}\n                </div>\n              ))}\n            </div>\n            {isPlayersTurn ? (\n              <button type=\"button\" onClick={() => send({ type: TicTacToeEventTypes.GIVE_UP_TURN_REQ })}>\n                Give up\n              </button>\n            ) : (\n              <button type=\"button\" disabled>\n                ---\n              </button>\n            )}\n          </div>\n        );\n      }\n\n      case machineState.matches(S.showingGameEndResults): {\n        return (\n          <div style={{ display: 'grid', gap: 16 }}>\n            <h3>Game ended</h3>\n            <div\n              style={{\n                display: 'grid',\n                gridTemplateColumns: '100px 100px 100px',\n                gridTemplateRows: '100px 100px 100px',\n                gap: 8,\n              }}\n            >\n              {machineState.context.field.map((cell, index) => (\n                <div\n                  // eslint-disable-next-line react/no-array-index-key\n                  key={index}\n                  title={`${index}`}\n                  style={{\n                    outline: '1px solid gray',\n                    cursor: 'pointer',\n                    fontSize: 50,\n                    display: 'flex',\n                    justifyContent: 'center',\n                    alignItems: 'center',\n                    background: machineState.context.winCombo?.includes(index as FieldCellIndex) ? 'green' : undefined,\n                  }}\n                >\n                  {cell}\n                </div>\n              ))}\n            </div>\n            <button type=\"button\" onClick={() => send({ type: TicTacToeEventTypes.RETRY_REQ })}>\n              Retry\n            </button>\n            <button type=\"button\" onClick={() => send({ type: TicTacToeEventTypes.SET_UP_NEW_GAME })}>\n              New game\n            </button>\n            {machineState.context.winCombo && <div>{`Win combination ${machineState.context.winCombo}`}</div>}\n            {machineState.context.surrendered && <div>{`${machineState.context.surrendered} surrendered!`}</div>}\n            {!machineState.context.winCombo && !machineState.context.surrendered && <div>It`s a draw</div>}\n          </div>\n        );\n      }\n\n      default:\n        return <div>UNKNOWN STATE</div>;\n    }\n  };\n\n  useEffect(() => {\n    // eslint-disable-next-line no-console\n    console.log({\n      turn: machineState.context.turnOrder.turnsMade,\n      context: machineState.context,\n      events: machineState.events,\n      value: machineState.value,\n    });\n  });\n\n  return (\n    <div\n      style={{\n        width: '50%',\n        margin: '10% auto auto auto',\n        display: 'flex',\n        flexDirection: 'column',\n        justifyContent: 'center',\n        alignItems: 'center',\n      }}\n    >\n      {renderMachineState()}\n    </div>\n  );\n};\n","import { TicTacToePage } from '../pages/TicTacToePage';\n\nexport const App: React.FC = () => {\n  return <TicTacToePage />;\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\nimport reportWebVitals from './reportWebVitals';\n\nimport { App } from './app-container';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}